{"version":3,"file":"zipkinPlugin.1ebdc265fc3bd7452fcd.js","sources":["webpack:////./public/app/plugins/datasource/zipkin/ConfigEditor.tsx","webpack:////./public/app/plugins/datasource/zipkin/QueryField.tsx","webpack:////./public/app/plugins/datasource/zipkin/constants.ts","webpack:////./public/app/plugins/datasource/zipkin/datasource.ts","webpack:////./public/app/plugins/datasource/zipkin/module.ts","webpack:////./public/app/plugins/datasource/zipkin/utils/transforms.ts"],"sourcesContent":["import React from 'react';\nimport { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { DataSourceHttpSettings } from '@grafana/ui';\n\nexport type Props = DataSourcePluginOptionsEditorProps;\n\nexport const ConfigEditor: React.FC<Props> = ({ options, onOptionsChange }) => {\n  return (\n    <DataSourceHttpSettings\n      defaultUrl={'http://localhost:9411'}\n      dataSourceConfig={options}\n      showAccessOptions={true}\n      onChange={onOptionsChange}\n    />\n  );\n};\n","import React, { useCallback, useMemo, useState } from 'react';\nimport { ZipkinDatasource, ZipkinQuery } from './datasource';\nimport { AppEvents, ExploreQueryFieldProps } from '@grafana/data';\nimport { ButtonCascader, CascaderOption } from '@grafana/ui';\nimport { useAsyncFn, useMount, useMountedState } from 'react-use';\nimport { appEvents } from '../../../core/core';\nimport { apiPrefix } from './constants';\nimport { ZipkinSpan } from './types';\nimport { fromPairs } from 'lodash';\nimport { AsyncState } from 'react-use/lib/useAsyncFn';\n\ntype Props = ExploreQueryFieldProps<ZipkinDatasource, ZipkinQuery>;\n\nexport const QueryField = ({ query, onChange, onRunQuery, datasource }: Props) => {\n  const serviceOptions = useServices(datasource);\n  const { onLoadOptions, allOptions } = useLoadOptions(datasource);\n\n  const onSelectTrace = useCallback(\n    (values: string[], selectedOptions: CascaderOption[]) => {\n      if (selectedOptions.length === 3) {\n        const traceID = selectedOptions[2].value;\n        onChange({ ...query, query: traceID });\n        onRunQuery();\n      }\n    },\n    [onChange, onRunQuery, query]\n  );\n\n  let cascaderOptions = useMapToCascaderOptions(serviceOptions, allOptions);\n\n  return (\n    <>\n      <div className=\"gf-form-inline gf-form-inline--nowrap\">\n        <div className=\"gf-form flex-shrink-0\">\n          <ButtonCascader options={cascaderOptions} onChange={onSelectTrace} loadData={onLoadOptions}>\n            Traces\n          </ButtonCascader>\n        </div>\n        <div className=\"gf-form gf-form--grow flex-shrink-1\">\n          <div className={'slate-query-field__wrapper'}>\n            <div className=\"slate-query-field\">\n              <input\n                style={{ width: '100%' }}\n                value={query.query || ''}\n                onChange={e =>\n                  onChange({\n                    ...query,\n                    query: e.currentTarget.value,\n                  })\n                }\n              />\n            </div>\n          </div>\n        </div>\n      </div>\n    </>\n  );\n};\n\n// Exported for tests\nexport function useServices(datasource: ZipkinDatasource): AsyncState<CascaderOption[]> {\n  const url = `${apiPrefix}/services`;\n\n  const [servicesOptions, fetch] = useAsyncFn(async (): Promise<CascaderOption[]> => {\n    try {\n      const services: string[] | null = await datasource.metadataRequest(url);\n      if (services) {\n        return services.sort().map(service => ({\n          label: service,\n          value: service,\n          isLeaf: false,\n        }));\n      }\n      return [];\n    } catch (error) {\n      appEvents.emit(AppEvents.alertError, ['Failed to load services from Zipkin', error]);\n      throw error;\n    }\n  }, [datasource]);\n\n  useMount(() => {\n    // We should probably call this periodically to get new services after mount.\n    fetch();\n  });\n\n  return servicesOptions;\n}\n\ntype OptionsState = {\n  [serviceName: string]: {\n    [spanName: string]: {\n      [traceId: string]: string;\n    };\n  };\n};\n\n// Exported for tests\nexport function useLoadOptions(datasource: ZipkinDatasource) {\n  const isMounted = useMountedState();\n  const [allOptions, setAllOptions] = useState({} as OptionsState);\n\n  const [, fetchSpans] = useAsyncFn(\n    async function findSpans(service: string): Promise<void> {\n      const url = `${apiPrefix}/spans`;\n      try {\n        // The response of this should have been full ZipkinSpan objects based on API docs but is just list\n        // of span names.\n        // TODO: check if this is some issue of version used or something else\n        const response: string[] = await datasource.metadataRequest(url, { serviceName: service });\n        if (isMounted()) {\n          setAllOptions(state => {\n            const spanOptions = fromPairs(response.map((span: string) => [span, undefined]));\n            return {\n              ...state,\n              [service]: spanOptions as any,\n            };\n          });\n        }\n      } catch (error) {\n        appEvents.emit(AppEvents.alertError, ['Failed to load spans from Zipkin', error]);\n        throw error;\n      }\n    },\n    [datasource, allOptions]\n  );\n\n  const [, fetchTraces] = useAsyncFn(\n    async function findTraces(serviceName: string, spanName: string): Promise<void> {\n      const url = `${apiPrefix}/traces`;\n      const search = {\n        serviceName,\n        spanName,\n        // See other params and default here https://zipkin.io/zipkin-api/#/default/get_traces\n      };\n      try {\n        // This should return just root traces as there isn't any nesting\n        const traces: ZipkinSpan[][] = await datasource.metadataRequest(url, search);\n        if (isMounted()) {\n          const newTraces = traces.length\n            ? fromPairs(\n                traces.map(trace => {\n                  const rootSpan = trace.find(span => !span.parentId)!;\n\n                  return [`${rootSpan.name} [${Math.floor(rootSpan.duration / 1000)} ms]`, rootSpan.traceId];\n                })\n              )\n            : noTracesOptions;\n\n          setAllOptions(state => {\n            const spans = state[serviceName];\n            return {\n              ...state,\n              [serviceName]: {\n                ...spans,\n                [spanName]: newTraces,\n              },\n            };\n          });\n        }\n      } catch (error) {\n        appEvents.emit(AppEvents.alertError, ['Failed to load spans from Zipkin', error]);\n        throw error;\n      }\n    },\n    [datasource]\n  );\n\n  const onLoadOptions = useCallback(\n    (selectedOptions: CascaderOption[]) => {\n      const service = selectedOptions[0].value;\n      if (selectedOptions.length === 1) {\n        fetchSpans(service);\n      } else if (selectedOptions.length === 2) {\n        const spanName = selectedOptions[1].value;\n        fetchTraces(service, spanName);\n      }\n    },\n    [fetchSpans, fetchTraces]\n  );\n\n  return {\n    onLoadOptions,\n    allOptions,\n  };\n}\n\nfunction useMapToCascaderOptions(services: AsyncState<CascaderOption[]>, allOptions: OptionsState) {\n  return useMemo(() => {\n    let cascaderOptions: CascaderOption[] = [];\n\n    if (services.value && services.value.length) {\n      cascaderOptions = services.value.map(services => {\n        return {\n          ...services,\n          children:\n            allOptions[services.value] &&\n            Object.keys(allOptions[services.value]).map(spanName => {\n              return {\n                label: spanName,\n                value: spanName,\n                isLeaf: false,\n                children:\n                  allOptions[services.value][spanName] &&\n                  Object.keys(allOptions[services.value][spanName]).map(traceName => {\n                    return {\n                      label: traceName,\n                      value: allOptions[services.value][spanName][traceName],\n                    };\n                  }),\n              };\n            }),\n        };\n      });\n    } else if (services.value && !services.value.length) {\n      cascaderOptions = noTracesFoundOptions;\n    }\n\n    return cascaderOptions;\n  }, [services, allOptions]);\n}\n\nconst NO_TRACES_KEY = '__NO_TRACES__';\nconst noTracesFoundOptions = [\n  {\n    label: 'No traces found',\n    value: 'no_traces',\n    isLeaf: true,\n\n    // Cannot be disabled because then cascader shows 'loading' for some reason.\n    // disabled: true,\n  },\n];\n\nconst noTracesOptions = {\n  '[No traces in time range]': NO_TRACES_KEY,\n};\n","export const apiPrefix = '/api/v2';\n","import {\n  MutableDataFrame,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataQuery,\n  FieldType,\n} from '@grafana/data';\nimport { from, Observable, of } from 'rxjs';\nimport { serializeParams } from '../../../core/utils/fetch';\nimport { getBackendSrv, BackendSrvRequest } from '@grafana/runtime';\nimport { map } from 'rxjs/operators';\nimport { apiPrefix } from './constants';\nimport { ZipkinSpan } from './types';\nimport { transformResponse } from './utils/transforms';\n\nexport interface ZipkinQuery extends DataQuery {\n  query: string;\n}\n\nexport class ZipkinDatasource extends DataSourceApi<ZipkinQuery> {\n  constructor(private instanceSettings: DataSourceInstanceSettings) {\n    super(instanceSettings);\n  }\n\n  query(options: DataQueryRequest<ZipkinQuery>): Observable<DataQueryResponse> {\n    const traceId = options.targets[0]?.query;\n    if (traceId) {\n      return this.request<ZipkinSpan[]>(`${apiPrefix}/trace/${encodeURIComponent(traceId)}`).pipe(\n        map(responseToDataQueryResponse)\n      );\n    } else {\n      return of(emptyDataQueryResponse);\n    }\n  }\n\n  async metadataRequest(url: string, params?: Record<string, any>): Promise<any> {\n    const res = await this.request(url, params, { hideFromInspector: true }).toPromise();\n    return res.data;\n  }\n\n  async testDatasource(): Promise<any> {\n    await this.metadataRequest(`${apiPrefix}/services`);\n    return true;\n  }\n\n  getQueryDisplayText(query: ZipkinQuery) {\n    return query.query;\n  }\n\n  private request<T = any>(apiUrl: string, data?: any, options?: Partial<BackendSrvRequest>): Observable<{ data: T }> {\n    // Hack for proxying metadata requests\n    const baseUrl = `/api/datasources/proxy/${this.instanceSettings.id}`;\n    const params = data ? serializeParams(data) : '';\n    const url = `${baseUrl}${apiUrl}${params.length ? `?${params}` : ''}`;\n    const req = {\n      ...options,\n      url,\n    };\n\n    return from(getBackendSrv().datasourceRequest(req));\n  }\n}\n\nfunction responseToDataQueryResponse(response: { data: ZipkinSpan[] }): DataQueryResponse {\n  return {\n    data: [\n      new MutableDataFrame({\n        fields: [\n          {\n            name: 'trace',\n            type: FieldType.trace,\n            // There is probably better mapping than just putting everything in as a single value but that's how\n            // we do it with jaeger and is the simplest right now.\n            values: response?.data ? [transformResponse(response?.data)] : [],\n          },\n        ],\n        meta: {\n          preferredVisualisationType: 'trace',\n        },\n      }),\n    ],\n  };\n}\n\nconst emptyDataQueryResponse = {\n  data: [\n    new MutableDataFrame({\n      fields: [\n        {\n          name: 'trace',\n          type: FieldType.trace,\n          values: [],\n        },\n      ],\n      meta: {\n        preferredVisualisationType: 'trace',\n      },\n    }),\n  ],\n};\n","import { DataSourcePlugin } from '@grafana/data';\nimport { ZipkinDatasource } from './datasource';\nimport { QueryField } from './QueryField';\nimport { ConfigEditor } from './ConfigEditor';\n\nexport const plugin = new DataSourcePlugin(ZipkinDatasource)\n  .setConfigEditor(ConfigEditor)\n  .setExploreQueryField(QueryField);\n","import { identity } from 'lodash';\nimport { keyBy } from 'lodash';\nimport { ZipkinAnnotation, ZipkinEndpoint, ZipkinSpan } from '../types';\nimport { TraceKeyValuePair, TraceLog, TraceProcess, TraceSpanData, TraceData } from '@grafana/data';\n\n/**\n * Transforms response to format similar to Jaegers as we use Jaeger ui on the frontend.\n */\nexport function transformResponse(zSpans: ZipkinSpan[]): TraceData & { spans: TraceSpanData[] } {\n  return {\n    processes: gatherProcesses(zSpans),\n    traceID: zSpans[0].traceId,\n    spans: zSpans.map(transformSpan),\n    warnings: null,\n  };\n}\n\nfunction transformSpan(span: ZipkinSpan): TraceSpanData {\n  const jaegerSpan: TraceSpanData = {\n    duration: span.duration,\n    // TODO: not sure what this is\n    flags: 1,\n    logs: span.annotations?.map(transformAnnotation) ?? [],\n    operationName: span.name,\n    processID: span.localEndpoint?.serviceName || span.remoteEndpoint?.serviceName || 'unknown',\n    startTime: span.timestamp,\n    spanID: span.id,\n    traceID: span.traceId,\n    warnings: null as any,\n    tags: Object.keys(span.tags || {}).map(key => {\n      // If tag is error we remap it to simple boolean so that the Jaeger ui will show an error icon.\n      return {\n        key,\n        type: key === 'error' ? 'bool' : 'string',\n        value: key === 'error' ? true : span.tags![key],\n      };\n    }),\n    references: span.parentId\n      ? [\n          {\n            refType: 'CHILD_OF',\n            spanID: span.parentId,\n            traceID: span.traceId,\n          },\n        ]\n      : [],\n  };\n  if (span.kind) {\n    jaegerSpan.tags = [\n      {\n        key: 'kind',\n        type: 'string',\n        value: span.kind,\n      },\n      ...jaegerSpan.tags,\n    ];\n  }\n\n  return jaegerSpan;\n}\n\n/**\n * Maps annotations as a Jaeger log as that seems to be the closest thing.\n * See https://zipkin.io/zipkin-api/#/default/get_trace__traceId_\n */\nfunction transformAnnotation(annotation: ZipkinAnnotation): TraceLog {\n  return {\n    timestamp: annotation.timestamp,\n    fields: [\n      {\n        key: 'annotation',\n        type: 'string',\n        value: annotation.value,\n      },\n    ],\n  };\n}\n\nfunction gatherProcesses(zSpans: ZipkinSpan[]): Record<string, TraceProcess> {\n  const processes = zSpans.reduce((acc, span) => {\n    if (span.localEndpoint) {\n      acc.push(endpointToProcess(span.localEndpoint));\n    }\n    if (span.remoteEndpoint) {\n      acc.push(endpointToProcess(span.remoteEndpoint));\n    }\n    return acc;\n  }, [] as TraceProcess[]);\n  return keyBy(processes, 'serviceName');\n}\n\nfunction endpointToProcess(endpoint: ZipkinEndpoint): TraceProcess {\n  return {\n    serviceName: endpoint.serviceName,\n    tags: [\n      valueToTag('ipv4', endpoint.ipv4, 'string'),\n      valueToTag('ipv6', endpoint.ipv6, 'string'),\n      valueToTag('port', endpoint.port, 'number'),\n    ].filter(identity) as TraceKeyValuePair[],\n  };\n}\n\nfunction valueToTag(key: string, value: string | number | undefined, type: string): TraceKeyValuePair | undefined {\n  if (!value) {\n    return undefined;\n  }\n  return {\n    key,\n    type,\n    value,\n  };\n}\n"],"mappings":"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ALA;AAQA;AACA;AADA;AAVA;AAFA;AAkBA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AADA;AARA;AAFA;;;;;;;;;;;;ACtFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAGA;AACA;AACA;AAHA;AArBA;AACA;AA4BA;AACA;AAEA;AACA;AACA;AAHA;AAOA;AACA;AACA;AACA;AAEA;;;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAHA;AAHA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAHA;AAKA;;;;A","sourceRoot":""}