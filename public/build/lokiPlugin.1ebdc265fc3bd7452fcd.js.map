{"version":3,"file":"lokiPlugin.1ebdc265fc3bd7452fcd.js","sources":["webpack:////./node_modules/charenc/charenc.js","webpack:////./node_modules/crypt/crypt.js","webpack:////./node_modules/is-buffer/index.js","webpack:////./node_modules/lodash/escapeRegExp.js","webpack:////./node_modules/md5/md5.js","webpack:////./node_modules/rxjs/_esm5/internal/observable/dom/WebSocketSubject.js","webpack:////./node_modules/rxjs/_esm5/internal/observable/dom/webSocket.js","webpack:////./node_modules/rxjs/_esm5/webSocket/index.js","webpack:////./public/app/core/components/Select/DataSourcePicker.tsx","webpack:////./public/app/features/explore/utils/links.ts","webpack:////./public/app/plugins/datasource/loki/LokiAnnotationsQueryCtrl.tsx","webpack:////./public/app/plugins/datasource/loki/components/LokiCheatSheet.tsx","webpack:////./public/app/plugins/datasource/loki/components/LokiExploreExtraField.tsx","webpack:////./public/app/plugins/datasource/loki/components/LokiExploreQueryEditor.tsx","webpack:////./public/app/plugins/datasource/loki/components/LokiQueryEditor.tsx","webpack:////./public/app/plugins/datasource/loki/components/LokiQueryField.tsx","webpack:////./public/app/plugins/datasource/loki/configuration/ConfigEditor.tsx","webpack:////./public/app/plugins/datasource/loki/configuration/DebugSection.tsx","webpack:////./public/app/plugins/datasource/loki/configuration/DerivedField.tsx","webpack:////./public/app/plugins/datasource/loki/configuration/DerivedFields.tsx","webpack:////./public/app/plugins/datasource/loki/configuration/MaxLinesField.tsx","webpack:////./public/app/plugins/datasource/loki/datasource.ts","webpack:////./public/app/plugins/datasource/loki/language_provider.ts","webpack:////./public/app/plugins/datasource/loki/live_streams.ts","webpack:////./public/app/plugins/datasource/loki/module.ts","webpack:////./public/app/plugins/datasource/loki/query_utils.ts","webpack:////./public/app/plugins/datasource/loki/result_transformer.ts","webpack:////./public/app/plugins/datasource/loki/syntax.ts","webpack:////./public/app/plugins/datasource/loki/types.ts"],"sourcesContent":["var charenc = {\n  // UTF-8 encoding\n  utf8: {\n    // Convert a string to a byte array\n    stringToBytes: function(str) {\n      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));\n    },\n\n    // Convert a byte array to a string\n    bytesToString: function(bytes) {\n      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));\n    }\n  },\n\n  // Binary encoding\n  bin: {\n    // Convert a string to a byte array\n    stringToBytes: function(str) {\n      for (var bytes = [], i = 0; i < str.length; i++)\n        bytes.push(str.charCodeAt(i) & 0xFF);\n      return bytes;\n    },\n\n    // Convert a byte array to a string\n    bytesToString: function(bytes) {\n      for (var str = [], i = 0; i < bytes.length; i++)\n        str.push(String.fromCharCode(bytes[i]));\n      return str.join('');\n    }\n  }\n};\n\nmodule.exports = charenc;\n","(function() {\n  var base64map\n      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n\n  crypt = {\n    // Bit-wise rotation left\n    rotl: function(n, b) {\n      return (n << b) | (n >>> (32 - b));\n    },\n\n    // Bit-wise rotation right\n    rotr: function(n, b) {\n      return (n << (32 - b)) | (n >>> b);\n    },\n\n    // Swap big-endian to little-endian and vice versa\n    endian: function(n) {\n      // If number given, swap endian\n      if (n.constructor == Number) {\n        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;\n      }\n\n      // Else, assume array and swap all items\n      for (var i = 0; i < n.length; i++)\n        n[i] = crypt.endian(n[i]);\n      return n;\n    },\n\n    // Generate an array of any length of random bytes\n    randomBytes: function(n) {\n      for (var bytes = []; n > 0; n--)\n        bytes.push(Math.floor(Math.random() * 256));\n      return bytes;\n    },\n\n    // Convert a byte array to big-endian 32-bit words\n    bytesToWords: function(bytes) {\n      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)\n        words[b >>> 5] |= bytes[i] << (24 - b % 32);\n      return words;\n    },\n\n    // Convert big-endian 32-bit words to a byte array\n    wordsToBytes: function(words) {\n      for (var bytes = [], b = 0; b < words.length * 32; b += 8)\n        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);\n      return bytes;\n    },\n\n    // Convert a byte array to a hex string\n    bytesToHex: function(bytes) {\n      for (var hex = [], i = 0; i < bytes.length; i++) {\n        hex.push((bytes[i] >>> 4).toString(16));\n        hex.push((bytes[i] & 0xF).toString(16));\n      }\n      return hex.join('');\n    },\n\n    // Convert a hex string to a byte array\n    hexToBytes: function(hex) {\n      for (var bytes = [], c = 0; c < hex.length; c += 2)\n        bytes.push(parseInt(hex.substr(c, 2), 16));\n      return bytes;\n    },\n\n    // Convert a byte array to a base-64 string\n    bytesToBase64: function(bytes) {\n      for (var base64 = [], i = 0; i < bytes.length; i += 3) {\n        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\n        for (var j = 0; j < 4; j++)\n          if (i * 8 + j * 6 <= bytes.length * 8)\n            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));\n          else\n            base64.push('=');\n      }\n      return base64.join('');\n    },\n\n    // Convert a base-64 string to a byte array\n    base64ToBytes: function(base64) {\n      // Remove non-base-64 characters\n      base64 = base64.replace(/[^A-Z0-9+\\/]/ig, '');\n\n      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;\n          imod4 = ++i % 4) {\n        if (imod4 == 0) continue;\n        bytes.push(((base64map.indexOf(base64.charAt(i - 1))\n            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))\n            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));\n      }\n      return bytes;\n    }\n  };\n\n  module.exports = crypt;\n})();\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n","var toString = require('./toString');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n    reHasRegExpChar = RegExp(reRegExpChar.source);\n\n/**\n * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to escape.\n * @returns {string} Returns the escaped string.\n * @example\n *\n * _.escapeRegExp('[lodash](https://lodash.com/)');\n * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n */\nfunction escapeRegExp(string) {\n  string = toString(string);\n  return (string && reHasRegExpChar.test(string))\n    ? string.replace(reRegExpChar, '\\\\$&')\n    : string;\n}\n\nmodule.exports = escapeRegExp;\n","(function(){\r\n  var crypt = require('crypt'),\r\n      utf8 = require('charenc').utf8,\r\n      isBuffer = require('is-buffer'),\r\n      bin = require('charenc').bin,\r\n\r\n  // The core\r\n  md5 = function (message, options) {\r\n    // Convert to byte array\r\n    if (message.constructor == String)\r\n      if (options && options.encoding === 'binary')\r\n        message = bin.stringToBytes(message);\r\n      else\r\n        message = utf8.stringToBytes(message);\r\n    else if (isBuffer(message))\r\n      message = Array.prototype.slice.call(message, 0);\r\n    else if (!Array.isArray(message))\r\n      message = message.toString();\r\n    // else, assume byte array already\r\n\r\n    var m = crypt.bytesToWords(message),\r\n        l = message.length * 8,\r\n        a =  1732584193,\r\n        b = -271733879,\r\n        c = -1732584194,\r\n        d =  271733878;\r\n\r\n    // Swap endian\r\n    for (var i = 0; i < m.length; i++) {\r\n      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |\r\n             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;\r\n    }\r\n\r\n    // Padding\r\n    m[l >>> 5] |= 0x80 << (l % 32);\r\n    m[(((l + 64) >>> 9) << 4) + 14] = l;\r\n\r\n    // Method shortcuts\r\n    var FF = md5._ff,\r\n        GG = md5._gg,\r\n        HH = md5._hh,\r\n        II = md5._ii;\r\n\r\n    for (var i = 0; i < m.length; i += 16) {\r\n\r\n      var aa = a,\r\n          bb = b,\r\n          cc = c,\r\n          dd = d;\r\n\r\n      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);\r\n      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);\r\n      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);\r\n      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);\r\n      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);\r\n      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);\r\n      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);\r\n      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);\r\n      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);\r\n      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);\r\n      c = FF(c, d, a, b, m[i+10], 17, -42063);\r\n      b = FF(b, c, d, a, m[i+11], 22, -1990404162);\r\n      a = FF(a, b, c, d, m[i+12],  7,  1804603682);\r\n      d = FF(d, a, b, c, m[i+13], 12, -40341101);\r\n      c = FF(c, d, a, b, m[i+14], 17, -1502002290);\r\n      b = FF(b, c, d, a, m[i+15], 22,  1236535329);\r\n\r\n      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);\r\n      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);\r\n      c = GG(c, d, a, b, m[i+11], 14,  643717713);\r\n      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);\r\n      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);\r\n      d = GG(d, a, b, c, m[i+10],  9,  38016083);\r\n      c = GG(c, d, a, b, m[i+15], 14, -660478335);\r\n      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);\r\n      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);\r\n      d = GG(d, a, b, c, m[i+14],  9, -1019803690);\r\n      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);\r\n      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);\r\n      a = GG(a, b, c, d, m[i+13],  5, -1444681467);\r\n      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);\r\n      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);\r\n      b = GG(b, c, d, a, m[i+12], 20, -1926607734);\r\n\r\n      a = HH(a, b, c, d, m[i+ 5],  4, -378558);\r\n      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);\r\n      c = HH(c, d, a, b, m[i+11], 16,  1839030562);\r\n      b = HH(b, c, d, a, m[i+14], 23, -35309556);\r\n      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);\r\n      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);\r\n      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);\r\n      b = HH(b, c, d, a, m[i+10], 23, -1094730640);\r\n      a = HH(a, b, c, d, m[i+13],  4,  681279174);\r\n      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);\r\n      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);\r\n      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);\r\n      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);\r\n      d = HH(d, a, b, c, m[i+12], 11, -421815835);\r\n      c = HH(c, d, a, b, m[i+15], 16,  530742520);\r\n      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);\r\n\r\n      a = II(a, b, c, d, m[i+ 0],  6, -198630844);\r\n      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);\r\n      c = II(c, d, a, b, m[i+14], 15, -1416354905);\r\n      b = II(b, c, d, a, m[i+ 5], 21, -57434055);\r\n      a = II(a, b, c, d, m[i+12],  6,  1700485571);\r\n      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);\r\n      c = II(c, d, a, b, m[i+10], 15, -1051523);\r\n      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);\r\n      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);\r\n      d = II(d, a, b, c, m[i+15], 10, -30611744);\r\n      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);\r\n      b = II(b, c, d, a, m[i+13], 21,  1309151649);\r\n      a = II(a, b, c, d, m[i+ 4],  6, -145523070);\r\n      d = II(d, a, b, c, m[i+11], 10, -1120210379);\r\n      c = II(c, d, a, b, m[i+ 2], 15,  718787259);\r\n      b = II(b, c, d, a, m[i+ 9], 21, -343485551);\r\n\r\n      a = (a + aa) >>> 0;\r\n      b = (b + bb) >>> 0;\r\n      c = (c + cc) >>> 0;\r\n      d = (d + dd) >>> 0;\r\n    }\r\n\r\n    return crypt.endian([a, b, c, d]);\r\n  };\r\n\r\n  // Auxiliary functions\r\n  md5._ff  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b & c | ~b & d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._gg  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b & d | c & ~d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._hh  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b ^ c ^ d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._ii  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n\r\n  // Package private blocksize\r\n  md5._blocksize = 16;\r\n  md5._digestsize = 16;\r\n\r\n  module.exports = function (message, options) {\r\n    if (message === undefined || message === null)\r\n      throw new Error('Illegal argument ' + message);\r\n\r\n    var digestbytes = crypt.wordsToBytes(md5(message, options));\r\n    return options && options.asBytes ? digestbytes :\r\n        options && options.asString ? bin.bytesToString(digestbytes) :\r\n        crypt.bytesToHex(digestbytes);\r\n  };\r\n\r\n})();\r\n","/** PURE_IMPORTS_START tslib,_.._Subject,_.._Subscriber,_.._Observable,_.._Subscription,_.._ReplaySubject PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject, AnonymousSubject } from '../../Subject';\nimport { Subscriber } from '../../Subscriber';\nimport { Observable } from '../../Observable';\nimport { Subscription } from '../../Subscription';\nimport { ReplaySubject } from '../../ReplaySubject';\nvar DEFAULT_WEBSOCKET_CONFIG = {\n    url: '',\n    deserializer: function (e) { return JSON.parse(e.data); },\n    serializer: function (value) { return JSON.stringify(value); },\n};\nvar WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT = 'WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }';\nvar WebSocketSubject = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(WebSocketSubject, _super);\n    function WebSocketSubject(urlConfigOrSource, destination) {\n        var _this = _super.call(this) || this;\n        if (urlConfigOrSource instanceof Observable) {\n            _this.destination = destination;\n            _this.source = urlConfigOrSource;\n        }\n        else {\n            var config = _this._config = tslib_1.__assign({}, DEFAULT_WEBSOCKET_CONFIG);\n            _this._output = new Subject();\n            if (typeof urlConfigOrSource === 'string') {\n                config.url = urlConfigOrSource;\n            }\n            else {\n                for (var key in urlConfigOrSource) {\n                    if (urlConfigOrSource.hasOwnProperty(key)) {\n                        config[key] = urlConfigOrSource[key];\n                    }\n                }\n            }\n            if (!config.WebSocketCtor && WebSocket) {\n                config.WebSocketCtor = WebSocket;\n            }\n            else if (!config.WebSocketCtor) {\n                throw new Error('no WebSocket constructor can be found');\n            }\n            _this.destination = new ReplaySubject();\n        }\n        return _this;\n    }\n    WebSocketSubject.prototype.lift = function (operator) {\n        var sock = new WebSocketSubject(this._config, this.destination);\n        sock.operator = operator;\n        sock.source = this;\n        return sock;\n    };\n    WebSocketSubject.prototype._resetState = function () {\n        this._socket = null;\n        if (!this.source) {\n            this.destination = new ReplaySubject();\n        }\n        this._output = new Subject();\n    };\n    WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {\n        var self = this;\n        return new Observable(function (observer) {\n            try {\n                self.next(subMsg());\n            }\n            catch (err) {\n                observer.error(err);\n            }\n            var subscription = self.subscribe(function (x) {\n                try {\n                    if (messageFilter(x)) {\n                        observer.next(x);\n                    }\n                }\n                catch (err) {\n                    observer.error(err);\n                }\n            }, function (err) { return observer.error(err); }, function () { return observer.complete(); });\n            return function () {\n                try {\n                    self.next(unsubMsg());\n                }\n                catch (err) {\n                    observer.error(err);\n                }\n                subscription.unsubscribe();\n            };\n        });\n    };\n    WebSocketSubject.prototype._connectSocket = function () {\n        var _this = this;\n        var _a = this._config, WebSocketCtor = _a.WebSocketCtor, protocol = _a.protocol, url = _a.url, binaryType = _a.binaryType;\n        var observer = this._output;\n        var socket = null;\n        try {\n            socket = protocol ?\n                new WebSocketCtor(url, protocol) :\n                new WebSocketCtor(url);\n            this._socket = socket;\n            if (binaryType) {\n                this._socket.binaryType = binaryType;\n            }\n        }\n        catch (e) {\n            observer.error(e);\n            return;\n        }\n        var subscription = new Subscription(function () {\n            _this._socket = null;\n            if (socket && socket.readyState === 1) {\n                socket.close();\n            }\n        });\n        socket.onopen = function (e) {\n            var _socket = _this._socket;\n            if (!_socket) {\n                socket.close();\n                _this._resetState();\n                return;\n            }\n            var openObserver = _this._config.openObserver;\n            if (openObserver) {\n                openObserver.next(e);\n            }\n            var queue = _this.destination;\n            _this.destination = Subscriber.create(function (x) {\n                if (socket.readyState === 1) {\n                    try {\n                        var serializer = _this._config.serializer;\n                        socket.send(serializer(x));\n                    }\n                    catch (e) {\n                        _this.destination.error(e);\n                    }\n                }\n            }, function (e) {\n                var closingObserver = _this._config.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                if (e && e.code) {\n                    socket.close(e.code, e.reason);\n                }\n                else {\n                    observer.error(new TypeError(WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT));\n                }\n                _this._resetState();\n            }, function () {\n                var closingObserver = _this._config.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                socket.close();\n                _this._resetState();\n            });\n            if (queue && queue instanceof ReplaySubject) {\n                subscription.add(queue.subscribe(_this.destination));\n            }\n        };\n        socket.onerror = function (e) {\n            _this._resetState();\n            observer.error(e);\n        };\n        socket.onclose = function (e) {\n            _this._resetState();\n            var closeObserver = _this._config.closeObserver;\n            if (closeObserver) {\n                closeObserver.next(e);\n            }\n            if (e.wasClean) {\n                observer.complete();\n            }\n            else {\n                observer.error(e);\n            }\n        };\n        socket.onmessage = function (e) {\n            try {\n                var deserializer = _this._config.deserializer;\n                observer.next(deserializer(e));\n            }\n            catch (err) {\n                observer.error(err);\n            }\n        };\n    };\n    WebSocketSubject.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var source = this.source;\n        if (source) {\n            return source.subscribe(subscriber);\n        }\n        if (!this._socket) {\n            this._connectSocket();\n        }\n        this._output.subscribe(subscriber);\n        subscriber.add(function () {\n            var _socket = _this._socket;\n            if (_this._output.observers.length === 0) {\n                if (_socket && _socket.readyState === 1) {\n                    _socket.close();\n                }\n                _this._resetState();\n            }\n        });\n        return subscriber;\n    };\n    WebSocketSubject.prototype.unsubscribe = function () {\n        var _socket = this._socket;\n        if (_socket && _socket.readyState === 1) {\n            _socket.close();\n        }\n        this._resetState();\n        _super.prototype.unsubscribe.call(this);\n    };\n    return WebSocketSubject;\n}(AnonymousSubject));\nexport { WebSocketSubject };\n//# sourceMappingURL=WebSocketSubject.js.map\n","/** PURE_IMPORTS_START _WebSocketSubject PURE_IMPORTS_END */\nimport { WebSocketSubject } from './WebSocketSubject';\nexport function webSocket(urlConfigOrSource) {\n    return new WebSocketSubject(urlConfigOrSource);\n}\n//# sourceMappingURL=webSocket.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport { webSocket as webSocket } from '../internal/observable/dom/webSocket';\nexport { WebSocketSubject } from '../internal/observable/dom/WebSocketSubject';\n//# sourceMappingURL=index.js.map\n","// Libraries\nimport React, { PureComponent } from 'react';\n\n// Components\nimport { Select } from '@grafana/ui';\nimport { SelectableValue, DataSourceSelectItem } from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\n\nexport interface Props {\n  onChange: (ds: DataSourceSelectItem) => void;\n  datasources: DataSourceSelectItem[];\n  current?: DataSourceSelectItem | null;\n  hideTextValue?: boolean;\n  onBlur?: () => void;\n  autoFocus?: boolean;\n  openMenuOnFocus?: boolean;\n  showLoading?: boolean;\n  placeholder?: string;\n  invalid?: boolean;\n}\n\nexport class DataSourcePicker extends PureComponent<Props> {\n  static defaultProps: Partial<Props> = {\n    autoFocus: false,\n    openMenuOnFocus: false,\n    placeholder: '选择数据源',\n  };\n\n  searchInput: HTMLElement;\n\n  constructor(props: Props) {\n    super(props);\n  }\n\n  onChange = (item: SelectableValue<string>) => {\n    const ds = this.props.datasources.find(ds => ds.name === item.value);\n\n    if (ds) {\n      this.props.onChange(ds);\n    }\n  };\n\n  render() {\n    const {\n      datasources,\n      current,\n      autoFocus,\n      hideTextValue,\n      onBlur,\n      openMenuOnFocus,\n      showLoading,\n      placeholder,\n      invalid,\n    } = this.props;\n\n    const options = datasources.map(ds => ({\n      value: ds.name,\n      label: ds.name,\n      imgUrl: ds.meta.info.logos.small,\n    }));\n\n    const value = current && {\n      label: current.name.substr(0, 37),\n      value: current.name,\n      imgUrl: current.meta.info.logos.small,\n      loading: showLoading,\n      hideText: hideTextValue,\n    };\n\n    return (\n      <div aria-label={selectors.components.DataSourcePicker.container}>\n        <Select\n          className=\"ds-picker select-container\"\n          isMulti={false}\n          isClearable={false}\n          backspaceRemovesValue={false}\n          onChange={this.onChange}\n          options={options}\n          autoFocus={autoFocus}\n          onBlur={onBlur}\n          openMenuOnFocus={openMenuOnFocus}\n          maxMenuHeight={500}\n          menuPlacement=\"bottom\"\n          placeholder={placeholder}\n          noOptionsMessage=\"No datasources found\"\n          value={value}\n          invalid={invalid}\n        />\n      </div>\n    );\n  }\n}\n\nexport default DataSourcePicker;\n","import { splitOpen } from '../state/actions';\nimport { Field, LinkModel, TimeRange } from '@grafana/data';\nimport { getLinkSrv } from '../../panel/panellinks/link_srv';\nimport { mapInternalLinkToExplore } from '@grafana/data/src/utils/dataLinks';\nimport { getDataSourceSrv, getTemplateSrv } from '@grafana/runtime';\n\n/**\n * Get links from the field of a dataframe and in addition check if there is associated\n * metadata with datasource in which case we will add onClick to open the link in new split window. This assumes\n * that we just supply datasource name and field value and Explore split window will know how to render that\n * appropriately. This is for example used for transition from log with traceId to trace datasource to show that\n * trace.\n */\nexport const getFieldLinksForExplore = (\n  field: Field,\n  rowIndex: number,\n  splitOpenFn: typeof splitOpen,\n  range: TimeRange\n): Array<LinkModel<Field>> => {\n  const scopedVars: any = {};\n  scopedVars['__value'] = {\n    value: {\n      raw: field.values.get(rowIndex),\n    },\n    text: 'Raw value',\n  };\n\n  return field.config.links\n    ? field.config.links.map(link => {\n        if (!link.internal) {\n          const linkModel = getLinkSrv().getDataLinkUIModel(link, scopedVars, field);\n          if (!linkModel.title) {\n            linkModel.title = getTitleFromHref(linkModel.href);\n          }\n          return linkModel;\n        } else {\n          return mapInternalLinkToExplore(link, scopedVars, range, field, {\n            onClickFn: splitOpenFn,\n            replaceVariables: getTemplateSrv().replace.bind(getTemplateSrv()),\n            getDataSourceSettingsByUid: getDataSourceSrv().getDataSourceSettingsByUid.bind(getDataSourceSrv()),\n          });\n        }\n      })\n    : [];\n};\n\nfunction getTitleFromHref(href: string): string {\n  // The URL constructor needs the url to have protocol\n  if (href.indexOf('://') < 0) {\n    // Doesn't really matter what protocol we use.\n    href = `http://${href}`;\n  }\n  let title;\n  try {\n    const parsedUrl = new URL(href);\n    title = parsedUrl.hostname;\n  } catch (_e) {\n    // Should be good enough fallback, user probably did not input valid url.\n    title = href;\n  }\n  return title;\n}\n","/**\n * Just a simple wrapper for a react component that is actually implementing the query editor.\n */\nexport class LokiAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n  annotation: any;\n\n  /** @ngInject */\n  constructor() {\n    this.annotation.target = this.annotation.target || {};\n    this.onQueryChange = this.onQueryChange.bind(this);\n  }\n\n  onQueryChange(expr: string) {\n    this.annotation.expr = expr;\n  }\n}\n","import React, { PureComponent } from 'react';\nimport { shuffle } from 'lodash';\nimport { ExploreStartPageProps, DataQuery } from '@grafana/data';\nimport LokiLanguageProvider from '../language_provider';\n\nconst DEFAULT_EXAMPLES = ['{job=\"default/prometheus\"}'];\nconst PREFERRED_LABELS = ['job', 'app', 'k8s_app'];\nconst EXAMPLES_LIMIT = 5;\n\nconst LOGQL_EXAMPLES = [\n  {\n    title: 'Count over time',\n    expression: 'count_over_time({job=\"mysql\"}[5m])',\n    label: 'This query counts all the log lines within the last five minutes for the MySQL job.',\n  },\n  {\n    title: 'Rate',\n    expression: 'rate(({job=\"mysql\"} |= \"error\" != \"timeout\")[10s])',\n    label:\n      'This query gets the per-second rate of all non-timeout errors within the last ten seconds for the MySQL job.',\n  },\n  {\n    title: 'Aggregate, count, and group',\n    expression: 'sum(count_over_time({job=\"mysql\"}[5m])) by (level)',\n    label: 'Get the count of logs during the last five minutes, grouping by level.',\n  },\n];\n\nexport default class LokiCheatSheet extends PureComponent<ExploreStartPageProps, { userExamples: string[] }> {\n  userLabelTimer: NodeJS.Timeout;\n  state = {\n    userExamples: DEFAULT_EXAMPLES,\n  };\n\n  componentDidMount() {\n    this.scheduleUserLabelChecking();\n  }\n\n  componentWillUnmount() {\n    clearTimeout(this.userLabelTimer);\n  }\n\n  scheduleUserLabelChecking() {\n    this.userLabelTimer = setTimeout(this.checkUserLabels, 1000);\n  }\n\n  checkUserLabels = async () => {\n    // Set example from user labels\n    const provider: LokiLanguageProvider = this.props.datasource?.languageProvider;\n    if (provider.started) {\n      const labels = provider.getLabelKeys() || [];\n      const preferredLabel = PREFERRED_LABELS.find(l => labels.includes(l));\n      if (preferredLabel) {\n        const values = await provider.getLabelValues(preferredLabel);\n        const userExamples = shuffle(values)\n          .slice(0, EXAMPLES_LIMIT)\n          .map(value => `{${preferredLabel}=\"${value}\"}`);\n        this.setState({ userExamples });\n      }\n    } else {\n      this.scheduleUserLabelChecking();\n    }\n  };\n\n  renderExpression(expr: string) {\n    const { onClickExample } = this.props;\n\n    return (\n      <div\n        className=\"cheat-sheet-item__example\"\n        key={expr}\n        onClick={e => onClickExample({ refId: 'A', expr } as DataQuery)}\n      >\n        <code>{expr}</code>\n      </div>\n    );\n  }\n\n  render() {\n    const { userExamples } = this.state;\n\n    return (\n      <div>\n        <h2>Loki Cheat Sheet</h2>\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">See your logs</div>\n          <div className=\"cheat-sheet-item__label\">Start by selecting a log stream from the Log labels selector.</div>\n          <div className=\"cheat-sheet-item__label\">\n            Alternatively, you can write a stream selector into the query field:\n          </div>\n          {this.renderExpression('{job=\"default/prometheus\"}')}\n          {userExamples !== DEFAULT_EXAMPLES && userExamples.length > 0 ? (\n            <div>\n              <div className=\"cheat-sheet-item__label\">Here are some example streams from your logs:</div>\n              {userExamples.map(example => this.renderExpression(example))}\n            </div>\n          ) : null}\n        </div>\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">Combine stream selectors</div>\n          {this.renderExpression('{app=\"cassandra\",namespace=\"prod\"}')}\n          <div className=\"cheat-sheet-item__label\">Returns all log lines from streams that have both labels.</div>\n        </div>\n\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">Filtering for search terms.</div>\n          {this.renderExpression('{app=\"cassandra\"} |~ \"(duration|latency)s*(=|is|of)s*[d.]+\"')}\n          {this.renderExpression('{app=\"cassandra\"} |= \"exact match\"')}\n          {this.renderExpression('{app=\"cassandra\"} != \"do not match\"')}\n          <div className=\"cheat-sheet-item__label\">\n            <a href=\"https://github.com/grafana/loki/blob/master/docs/logql.md#filter-expression\" target=\"logql\">\n              LogQL\n            </a>{' '}\n            supports exact and regular expression filters.\n          </div>\n        </div>\n        {LOGQL_EXAMPLES.map(item => (\n          <div className=\"cheat-sheet-item\" key={item.expression}>\n            <div className=\"cheat-sheet-item__title\">{item.title}</div>\n            {this.renderExpression(item.expression)}\n            <div className=\"cheat-sheet-item__label\">{item.label}</div>\n          </div>\n        ))}\n      </div>\n    );\n  }\n}\n","// Libraries\nimport React, { memo } from 'react';\n\n// Types\nimport { InlineFormLabel } from '@grafana/ui';\n\nexport interface LokiExploreExtraFieldProps {\n  label: string;\n  onChangeFunc: (e: React.SyntheticEvent<HTMLInputElement>) => void;\n  onKeyDownFunc: (e: React.KeyboardEvent<HTMLInputElement>) => void;\n  value: string;\n  type?: string;\n  min?: number;\n}\n\nexport function LokiExploreExtraField(props: LokiExploreExtraFieldProps) {\n  const { label, onChangeFunc, onKeyDownFunc, value, type, min } = props;\n\n  return (\n    <div className=\"gf-form-inline\">\n      <div className=\"gf-form\">\n        <InlineFormLabel width={5}>{label}</InlineFormLabel>\n        <input\n          type={type}\n          className=\"gf-form-input width-4\"\n          placeholder={'auto'}\n          onChange={onChangeFunc}\n          onKeyDown={onKeyDownFunc}\n          min={min}\n          value={value}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default memo(LokiExploreExtraField);\n","// Libraries\nimport React, { memo } from 'react';\nimport _ from 'lodash';\n\n// Types\nimport { ExploreQueryFieldProps } from '@grafana/data';\nimport { LokiDatasource } from '../datasource';\nimport { LokiQuery, LokiOptions } from '../types';\nimport { LokiQueryField } from './LokiQueryField';\nimport LokiExploreExtraField from './LokiExploreExtraField';\n\ntype Props = ExploreQueryFieldProps<LokiDatasource, LokiQuery, LokiOptions>;\n\nexport function LokiExploreQueryEditor(props: Props) {\n  const { range, query, data, datasource, history, onChange, onRunQuery } = props;\n\n  function onChangeQueryLimit(value: string) {\n    const { query, onChange } = props;\n    const nextQuery = { ...query, maxLines: preprocessMaxLines(value) };\n    onChange(nextQuery);\n  }\n\n  function preprocessMaxLines(value: string): number {\n    if (value.length === 0) {\n      // empty input - falls back to dataSource.maxLines limit\n      return NaN;\n    } else if (value.length > 0 && (isNaN(+value) || +value < 0)) {\n      // input with at least 1 character and that is either incorrect (value in the input field is not a number) or negative\n      // falls back to the limit of 0 lines\n      return 0;\n    } else {\n      // default case - correct input\n      return +value;\n    }\n  }\n\n  function onMaxLinesChange(e: React.SyntheticEvent<HTMLInputElement>) {\n    if (query.maxLines !== preprocessMaxLines(e.currentTarget.value)) {\n      onChangeQueryLimit(e.currentTarget.value);\n    }\n  }\n\n  function onReturnKeyDown(e: React.KeyboardEvent<HTMLInputElement>) {\n    if (e.key === 'Enter') {\n      onRunQuery();\n    }\n  }\n\n  return (\n    <LokiQueryField\n      datasource={datasource}\n      query={query}\n      onChange={onChange}\n      onBlur={() => {}}\n      onRunQuery={onRunQuery}\n      history={history}\n      data={data}\n      range={range}\n      ExtraFieldElement={\n        <LokiExploreExtraField\n          label={'Line limit'}\n          onChangeFunc={onMaxLinesChange}\n          onKeyDownFunc={onReturnKeyDown}\n          value={query?.maxLines?.toString() || ''}\n          type={'number'}\n          min={0}\n        />\n      }\n    />\n  );\n}\n\nexport default memo(LokiExploreQueryEditor);\n","// Libraries\nimport React, { PureComponent } from 'react';\n\n// Types\nimport { QueryEditorProps } from '@grafana/data';\nimport { InlineFormLabel } from '@grafana/ui';\nimport { LokiDatasource } from '../datasource';\nimport { LokiQuery } from '../types';\nimport { LokiQueryField } from './LokiQueryField';\n\ntype Props = QueryEditorProps<LokiDatasource, LokiQuery>;\n\ninterface State {\n  legendFormat: string;\n}\n\nexport class LokiQueryEditor extends PureComponent<Props, State> {\n  // Query target to be modified and used for queries\n  query: LokiQuery;\n\n  constructor(props: Props) {\n    super(props);\n    // Use default query to prevent undefined input values\n    const defaultQuery: Partial<LokiQuery> = { expr: '', legendFormat: '' };\n    const query = Object.assign({}, defaultQuery, props.query);\n    this.query = query;\n    // Query target properties that are fully controlled inputs\n    this.state = {\n      // Fully controlled text inputs\n      legendFormat: query.legendFormat ?? '',\n    };\n  }\n\n  onFieldChange = (query: LokiQuery, override?: any) => {\n    this.query.expr = query.expr;\n  };\n\n  onLegendChange = (e: React.SyntheticEvent<HTMLInputElement>) => {\n    const legendFormat = e.currentTarget.value;\n    this.query.legendFormat = legendFormat;\n    this.setState({ legendFormat });\n  };\n\n  onRunQuery = () => {\n    const { query } = this;\n    this.props.onChange(query);\n    this.props.onRunQuery();\n  };\n\n  render() {\n    const { datasource, query, data, range } = this.props;\n    const { legendFormat } = this.state;\n\n    return (\n      <div>\n        <LokiQueryField\n          datasource={datasource}\n          query={query}\n          onChange={this.onFieldChange}\n          onRunQuery={this.onRunQuery}\n          history={[]}\n          data={data}\n          range={range}\n        />\n\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              width={7}\n              tooltip=\"使用名称或模式控制时间序列的名称。 例如，{{hostname}}将替换为标签主机名的标签值。\"\n            >\n              图例\n            </InlineFormLabel>\n            <input\n              type=\"text\"\n              className=\"gf-form-input\"\n              placeholder=\"图例格式\"\n              value={legendFormat}\n              onChange={this.onLegendChange}\n              onBlur={this.onRunQuery}\n            />\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default LokiQueryEditor;\n","import React, { FunctionComponent } from 'react';\nimport { LokiQueryFieldForm, LokiQueryFieldFormProps } from './LokiQueryFieldForm';\nimport { useLokiSyntaxAndLabels } from './useLokiSyntaxAndLabels';\nimport LokiLanguageProvider from '../language_provider';\n\ntype LokiQueryFieldProps = Omit<\n  LokiQueryFieldFormProps,\n  'syntax' | 'syntaxLoaded' | 'onLoadOptions' | 'onLabelsRefresh' | 'logLabelOptions' | 'absoluteRange'\n>;\n\nexport const LokiQueryField: FunctionComponent<LokiQueryFieldProps> = props => {\n  const { datasource, range, ...otherProps } = props;\n  const absoluteTimeRange = { from: range!.from!.valueOf(), to: range!.to!.valueOf() }; // Range here is never optional\n\n  const { isSyntaxReady, setActiveOption, refreshLabels, syntax, logLabelOptions } = useLokiSyntaxAndLabels(\n    datasource.languageProvider as LokiLanguageProvider,\n    absoluteTimeRange\n  );\n\n  return (\n    <LokiQueryFieldForm\n      datasource={datasource}\n      /**\n       * setActiveOption name is intentional. Because of the way rc-cascader requests additional data\n       * https://github.com/react-component/cascader/blob/master/src/Cascader.jsx#L165\n       * we are notyfing useLokiSyntax hook, what the active option is, and then it's up to the hook logic\n       * to fetch data of options that aren't fetched yet\n       */\n      onLoadOptions={setActiveOption}\n      onLabelsRefresh={refreshLabels}\n      absoluteRange={absoluteTimeRange}\n      syntax={syntax}\n      syntaxLoaded={isSyntaxReady}\n      logLabelOptions={logLabelOptions}\n      {...otherProps}\n    />\n  );\n};\n\nexport default LokiQueryField;\n","import React from 'react';\nimport { DataSourcePluginOptionsEditorProps, DataSourceSettings } from '@grafana/data';\nimport { DataSourceHttpSettings } from '@grafana/ui';\nimport { LokiOptions } from '../types';\nimport { MaxLinesField } from './MaxLinesField';\nimport { DerivedFields } from './DerivedFields';\n\nexport type Props = DataSourcePluginOptionsEditorProps<LokiOptions>;\n\nconst makeJsonUpdater = <T extends any>(field: keyof LokiOptions) => (\n  options: DataSourceSettings<LokiOptions>,\n  value: T\n): DataSourceSettings<LokiOptions> => {\n  return {\n    ...options,\n    jsonData: {\n      ...options.jsonData,\n      [field]: value,\n    },\n  };\n};\n\nconst setMaxLines = makeJsonUpdater('maxLines');\nconst setDerivedFields = makeJsonUpdater('derivedFields');\n\nexport const ConfigEditor = (props: Props) => {\n  const { options, onOptionsChange } = props;\n\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl={'http://localhost:3100'}\n        dataSourceConfig={options}\n        showAccessOptions={false}\n        onChange={onOptionsChange}\n      />\n\n      <div className=\"gf-form-group\">\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <MaxLinesField\n              value={options.jsonData.maxLines || ''}\n              onChange={value => onOptionsChange(setMaxLines(options, value))}\n            />\n          </div>\n        </div>\n      </div>\n\n      <DerivedFields\n        value={options.jsonData.derivedFields}\n        onChange={value => onOptionsChange(setDerivedFields(options, value))}\n      />\n    </>\n  );\n};\n","import React, { useState } from 'react';\nimport { css } from 'emotion';\nimport cx from 'classnames';\nimport { LegacyForms } from '@grafana/ui';\nconst { FormField } = LegacyForms;\nimport { DerivedFieldConfig } from '../types';\nimport { ArrayVector, Field, FieldType, LinkModel } from '@grafana/data';\nimport { getFieldLinksForExplore } from '../../../../features/explore/utils/links';\n\ntype Props = {\n  derivedFields?: DerivedFieldConfig[];\n  className?: string;\n};\nexport const DebugSection = (props: Props) => {\n  const { derivedFields, className } = props;\n  const [debugText, setDebugText] = useState('');\n\n  let debugFields: DebugField[] = [];\n  if (debugText && derivedFields) {\n    debugFields = makeDebugFields(derivedFields, debugText);\n  }\n\n  return (\n    <div className={className}>\n      <FormField\n        labelWidth={12}\n        label={'Debug log message'}\n        inputEl={\n          <textarea\n            placeholder={'Paste an example log line here to test the regular expressions of your derived fields'}\n            className={cx(\n              'gf-form-input gf-form-textarea',\n              css`\n                width: 100%;\n              `\n            )}\n            value={debugText}\n            onChange={event => setDebugText(event.currentTarget.value)}\n          />\n        }\n      />\n      {!!debugFields.length && <DebugFields fields={debugFields} />}\n    </div>\n  );\n};\n\ntype DebugFieldItemProps = {\n  fields: DebugField[];\n};\nconst DebugFields = ({ fields }: DebugFieldItemProps) => {\n  return (\n    <table className={'filter-table'}>\n      <thead>\n        <tr>\n          <th>Name</th>\n          <th>Value</th>\n          <th>Url</th>\n        </tr>\n      </thead>\n      <tbody>\n        {fields.map(field => {\n          let value: any = field.value;\n          if (field.error) {\n            value = field.error.message;\n          } else if (field.href) {\n            value = <a href={field.href}>{value}</a>;\n          }\n          return (\n            <tr key={`${field.name}=${field.value}`}>\n              <td>{field.name}</td>\n              <td>{value}</td>\n              <td>{field.href ? <a href={field.href}>{field.href}</a> : ''}</td>\n            </tr>\n          );\n        })}\n      </tbody>\n    </table>\n  );\n};\n\ntype DebugField = {\n  name: string;\n  error?: any;\n  value?: string;\n  href?: string;\n};\n\nfunction makeDebugFields(derivedFields: DerivedFieldConfig[], debugText: string): DebugField[] {\n  return derivedFields\n    .filter(field => field.name && field.matcherRegex)\n    .map(field => {\n      try {\n        const testMatch = debugText.match(field.matcherRegex);\n        const value = testMatch && testMatch[1];\n        let link: LinkModel<Field> | null = null;\n\n        if (field.url && value) {\n          link = getFieldLinksForExplore(\n            {\n              name: '',\n              type: FieldType.string,\n              values: new ArrayVector([value]),\n              config: {\n                links: [{ title: '', url: field.url }],\n              },\n            },\n            0,\n            (() => {}) as any,\n            {} as any\n          )[0];\n        }\n\n        return {\n          name: field.name,\n          value: value || '<no match>',\n          href: link && link.href,\n        } as DebugField;\n      } catch (error) {\n        return {\n          name: field.name,\n          error,\n        } as DebugField;\n      }\n    });\n}\n","import React, { useEffect, useState } from 'react';\nimport { css } from 'emotion';\nimport { Button, DataLinkInput, stylesFactory, LegacyForms } from '@grafana/ui';\nconst { Switch, FormField } = LegacyForms;\nimport { VariableSuggestion } from '@grafana/data';\nimport { DataSourceSelectItem } from '@grafana/data';\n\nimport { DerivedFieldConfig } from '../types';\nimport DataSourcePicker from 'app/core/components/Select/DataSourcePicker';\nimport { getDatasourceSrv } from 'app/features/plugins/datasource_srv';\nimport { usePrevious } from 'react-use';\n\nconst getStyles = stylesFactory(() => ({\n  row: css`\n    display: flex;\n    align-items: baseline;\n  `,\n  nameField: css`\n    flex: 2;\n  `,\n  regexField: css`\n    flex: 3;\n  `,\n}));\n\ntype Props = {\n  value: DerivedFieldConfig;\n  onChange: (value: DerivedFieldConfig) => void;\n  onDelete: () => void;\n  suggestions: VariableSuggestion[];\n  className?: string;\n};\nexport const DerivedField = (props: Props) => {\n  const { value, onChange, onDelete, suggestions, className } = props;\n  const styles = getStyles();\n  const [showInternalLink, setShowInternalLink] = useState(!!value.datasourceUid);\n  const previousUid = usePrevious(value.datasourceUid);\n\n  // Force internal link visibility change if uid changed outside of this component.\n  useEffect(() => {\n    if (!previousUid && value.datasourceUid && !showInternalLink) {\n      setShowInternalLink(true);\n    }\n    if (previousUid && !value.datasourceUid && showInternalLink) {\n      setShowInternalLink(false);\n    }\n  }, [previousUid, value.datasourceUid, showInternalLink]);\n\n  const handleChange = (field: keyof typeof value) => (event: React.ChangeEvent<HTMLInputElement>) => {\n    onChange({\n      ...value,\n      [field]: event.currentTarget.value,\n    });\n  };\n\n  return (\n    <div className={className}>\n      <div className={styles.row}>\n        <FormField\n          className={styles.nameField}\n          labelWidth={5}\n          // A bit of a hack to prevent using default value for the width from FormField\n          inputWidth={null}\n          label=\"名字\"\n          type=\"text\"\n          value={value.name}\n          onChange={handleChange('name')}\n        />\n        <FormField\n          className={styles.regexField}\n          inputWidth={null}\n          label=\"正则\"\n          type=\"text\"\n          value={value.matcherRegex}\n          onChange={handleChange('matcherRegex')}\n          tooltip={'用于解析和捕获日志消息的某些部分。 您可以在模板中使用捕获的组。'}\n        />\n        <Button\n          variant=\"destructive\"\n          title=\"移除字段\"\n          icon=\"times\"\n          onClick={event => {\n            event.preventDefault();\n            onDelete();\n          }}\n          className={css`\n            margin-left: 8px;\n          `}\n        />\n      </div>\n\n      <FormField\n        label={showInternalLink ? 'Query' : 'URL'}\n        labelWidth={5}\n        inputEl={\n          <DataLinkInput\n            placeholder={showInternalLink ? '${__value.raw}' : 'http://example.com/${__value.raw}'}\n            value={value.url || ''}\n            onChange={newValue =>\n              onChange({\n                ...value,\n                url: newValue,\n              })\n            }\n            suggestions={suggestions}\n          />\n        }\n        className={css`\n          width: 100%;\n        `}\n      />\n\n      <div className={styles.row}>\n        <Switch\n          label=\"内部连结\"\n          checked={showInternalLink}\n          onChange={() => {\n            if (showInternalLink) {\n              onChange({\n                ...value,\n                datasourceUid: undefined,\n              });\n            }\n            setShowInternalLink(!showInternalLink);\n          }}\n        />\n\n        {showInternalLink && (\n          <DataSourceSection\n            onChange={datasourceUid => {\n              onChange({\n                ...value,\n                datasourceUid,\n              });\n            }}\n            datasourceUid={value.datasourceUid}\n          />\n        )}\n      </div>\n    </div>\n  );\n};\n\ntype DataSourceSectionProps = {\n  datasourceUid?: string;\n  onChange: (uid: string) => void;\n};\n\nconst DataSourceSection = (props: DataSourceSectionProps) => {\n  const { datasourceUid, onChange } = props;\n  const datasources: DataSourceSelectItem[] = getDatasourceSrv()\n    .getExternal()\n    // At this moment only Jaeger and Zipkin datasource is supported as the link target.\n    .filter(ds => ds.meta.tracing)\n    .map(\n      ds =>\n        ({\n          value: ds.uid,\n          name: ds.name,\n          meta: ds.meta,\n        } as DataSourceSelectItem)\n    );\n\n  let selectedDatasource = datasourceUid && datasources.find(d => d.value === datasourceUid);\n  return (\n    <DataSourcePicker\n      // Uid and value should be always set in the db and so in the items.\n      onChange={ds => onChange(ds.value!)}\n      datasources={datasources}\n      current={selectedDatasource || undefined}\n    />\n  );\n};\n","import React, { useState } from 'react';\nimport { css } from 'emotion';\nimport { Button, stylesFactory, useTheme } from '@grafana/ui';\nimport { GrafanaTheme, VariableOrigin, DataLinkBuiltInVars } from '@grafana/data';\nimport { DerivedFieldConfig } from '../types';\nimport { DerivedField } from './DerivedField';\nimport { DebugSection } from './DebugSection';\n\nconst getStyles = stylesFactory((theme: GrafanaTheme) => ({\n  infoText: css`\n    padding-bottom: ${theme.spacing.md};\n    color: ${theme.colors.textWeak};\n  `,\n  derivedField: css`\n    margin-bottom: ${theme.spacing.sm};\n  `,\n}));\n\ntype Props = {\n  value?: DerivedFieldConfig[];\n  onChange: (value: DerivedFieldConfig[]) => void;\n};\n\nexport const DerivedFields = (props: Props) => {\n  const { value, onChange } = props;\n  const theme = useTheme();\n  const styles = getStyles(theme);\n\n  const [showDebug, setShowDebug] = useState(false);\n\n  return (\n    <>\n      <h3 className=\"page-heading\">派生字段</h3>\n\n      <div className={styles.infoText}>派生字段可用于从日志消息中提取新字段，并根据其值创建链接。</div>\n\n      <div className=\"gf-form-group\">\n        {value &&\n          value.map((field, index) => {\n            return (\n              <DerivedField\n                className={styles.derivedField}\n                key={index}\n                value={field}\n                onChange={newField => {\n                  const newDerivedFields = [...value];\n                  newDerivedFields.splice(index, 1, newField);\n                  onChange(newDerivedFields);\n                }}\n                onDelete={() => {\n                  const newDerivedFields = [...value];\n                  newDerivedFields.splice(index, 1);\n                  onChange(newDerivedFields);\n                }}\n                suggestions={[\n                  {\n                    value: DataLinkBuiltInVars.valueRaw,\n                    label: '原始值',\n                    documentation: '正则表达式捕获的确切字符串',\n                    origin: VariableOrigin.Value,\n                  },\n                ]}\n              />\n            );\n          })}\n        <div>\n          <Button\n            variant=\"secondary\"\n            className={css`\n              margin-right: 10px;\n            `}\n            icon=\"plus\"\n            onClick={event => {\n              event.preventDefault();\n              const newDerivedFields = [...(value || []), { name: '', matcherRegex: '' }];\n              onChange(newDerivedFields);\n            }}\n          >\n            添加\n          </Button>\n\n          {value && value.length > 0 && (\n            <Button variant=\"secondary\" onClick={() => setShowDebug(!showDebug)}>\n              {showDebug ? '隐藏示例日志消息' : '显示示例日志消息'}\n            </Button>\n          )}\n        </div>\n      </div>\n\n      {showDebug && (\n        <div className=\"gf-form-group\">\n          <DebugSection\n            className={css`\n              margin-bottom: 10px;\n            `}\n            derivedFields={value}\n          />\n        </div>\n      )}\n    </>\n  );\n};\n","import React from 'react';\nimport { LegacyForms } from '@grafana/ui';\nconst { FormField } = LegacyForms;\n\ntype Props = {\n  value: string;\n  onChange: (value: string) => void;\n};\n\nexport const MaxLinesField = (props: Props) => {\n  const { value, onChange } = props;\n  return (\n    <FormField\n      label=\"最大行数\"\n      labelWidth={11}\n      inputWidth={20}\n      inputEl={\n        <input\n          type=\"number\"\n          className=\"gf-form-input width-8 gf-form-input--has-help-icon\"\n          value={value}\n          onChange={event => onChange(event.currentTarget.value)}\n          spellCheck={false}\n          placeholder=\"1000\"\n        />\n      }\n      tooltip={\n        <>\n          Loki查询必须包含返回的最大行数限制（默认值：1000）。 增加此限制可为临时分析提供更大的结果集。\n          如果显示日志结果时浏览器变慢，请减小此限制。\n        </>\n      }\n    />\n  );\n};\n","// Libraries\nimport { cloneDeep, isEmpty, map as lodashMap } from 'lodash';\nimport { merge, Observable, of } from 'rxjs';\nimport { catchError, map, switchMap } from 'rxjs/operators';\n\n// Types\nimport {\n  AnnotationEvent,\n  AnnotationQueryRequest,\n  DataFrame,\n  DataFrameView,\n  DataQueryError,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  dateMath,\n  DateTime,\n  FieldCache,\n  LoadingState,\n  LogRowModel,\n  PluginMeta,\n  QueryResultMeta,\n  ScopedVars,\n  TimeRange,\n  CoreApp,\n} from '@grafana/data';\nimport { BackendSrvRequest, FetchError, getBackendSrv } from '@grafana/runtime';\nimport { addLabelToQuery } from 'app/plugins/datasource/prometheus/add_label_to_query';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport { convertToWebSocketUrl } from 'app/core/utils/explore';\nimport { lokiResultsToTableModel, lokiStreamResultToDataFrame, processRangeQueryResponse } from './result_transformer';\nimport { getHighlighterExpressionsFromQuery } from './query_utils';\nimport { getTimeSrv } from 'app/features/dashboard/services/TimeSrv';\n\nimport {\n  LokiOptions,\n  LokiQuery,\n  LokiRangeQueryRequest,\n  LokiResponse,\n  LokiResultType,\n  LokiStreamResponse,\n} from './types';\nimport { LiveStreams, LokiLiveTarget } from './live_streams';\nimport LanguageProvider, { rangeToParams } from './language_provider';\nimport { serializeParams } from '../../../core/utils/fetch';\nimport { RowContextOptions } from '@grafana/ui/src/components/Logs/LogRowContextProvider';\n\nexport type RangeQueryOptions = DataQueryRequest<LokiQuery> | AnnotationQueryRequest<LokiQuery>;\nexport const DEFAULT_MAX_LINES = 1000;\nexport const LOKI_ENDPOINT = '/loki/api/v1';\n\nconst RANGE_QUERY_ENDPOINT = `${LOKI_ENDPOINT}/query_range`;\nconst INSTANT_QUERY_ENDPOINT = `${LOKI_ENDPOINT}/query`;\n\nconst DEFAULT_QUERY_PARAMS: Partial<LokiRangeQueryRequest> = {\n  direction: 'BACKWARD',\n  limit: DEFAULT_MAX_LINES,\n  query: '',\n};\n\nexport class LokiDatasource extends DataSourceApi<LokiQuery, LokiOptions> {\n  private streams = new LiveStreams();\n  languageProvider: LanguageProvider;\n  maxLines: number;\n\n  /** @ngInject */\n  constructor(private instanceSettings: DataSourceInstanceSettings<LokiOptions>, private templateSrv: TemplateSrv) {\n    super(instanceSettings);\n\n    this.languageProvider = new LanguageProvider(this);\n    const settingsData = instanceSettings.jsonData || {};\n    this.maxLines = parseInt(settingsData.maxLines ?? '0', 10) || DEFAULT_MAX_LINES;\n  }\n\n  _request(apiUrl: string, data?: any, options?: Partial<BackendSrvRequest>): Observable<Record<string, any>> {\n    const baseUrl = this.instanceSettings.url;\n    const params = data ? serializeParams(data) : '';\n    const url = `${baseUrl}${apiUrl}${params.length ? `?${params}` : ''}`;\n    const req = {\n      ...options,\n      url,\n    };\n\n    return getBackendSrv().fetch<Record<string, any>>(req);\n  }\n\n  query(options: DataQueryRequest<LokiQuery>): Observable<DataQueryResponse> {\n    const subQueries: Array<Observable<DataQueryResponse>> = [];\n    const filteredTargets = options.targets\n      .filter(target => target.expr && !target.hide)\n      .map(target => ({\n        ...target,\n        expr: this.templateSrv.replace(target.expr, options.scopedVars, this.interpolateQueryExpr),\n      }));\n\n    for (const target of filteredTargets) {\n      if (options.app === CoreApp.Explore) {\n        subQueries.push(this.runInstantQuery(target, options, filteredTargets.length));\n      }\n      subQueries.push(this.runRangeQuery(target, options, filteredTargets.length));\n    }\n\n    // No valid targets, return the empty result to save a round trip.\n    if (isEmpty(subQueries)) {\n      return of({\n        data: [],\n        state: LoadingState.Done,\n      });\n    }\n\n    return merge(...subQueries);\n  }\n\n  runInstantQuery = (\n    target: LokiQuery,\n    options: DataQueryRequest<LokiQuery>,\n    responseListLength: number\n  ): Observable<DataQueryResponse> => {\n    const timeNs = this.getTime(options.range.to, true);\n    const query = {\n      query: target.expr,\n      time: `${timeNs + (1e9 - (timeNs % 1e9))}`,\n      limit: Math.min(options.maxDataPoints || Infinity, this.maxLines),\n    };\n    /** Show results of Loki instant queries only in table */\n    const meta: QueryResultMeta = {\n      preferredVisualisationType: 'table',\n    };\n\n    return this._request(INSTANT_QUERY_ENDPOINT, query).pipe(\n      map((response: { data: LokiResponse }) => {\n        if (response.data.data.resultType === LokiResultType.Stream) {\n          return {\n            data: [],\n            key: `${target.refId}_instant`,\n          };\n        }\n\n        return {\n          data: [lokiResultsToTableModel(response.data.data.result, responseListLength, target.refId, meta, true)],\n          key: `${target.refId}_instant`,\n        };\n      }),\n      catchError((err: any) => this.throwUnless(err, err.status === 404, target))\n    );\n  };\n\n  createRangeQuery(target: LokiQuery, options: RangeQueryOptions): LokiRangeQueryRequest {\n    const query = target.expr;\n    let range: { start?: number; end?: number; step?: number } = {};\n    if (options.range) {\n      const startNs = this.getTime(options.range.from, false);\n      const endNs = this.getTime(options.range.to, true);\n      const rangeMs = Math.ceil((endNs - startNs) / 1e6);\n      const step = Math.ceil(\n        this.adjustInterval((options as DataQueryRequest<LokiQuery>).intervalMs || 1000, rangeMs) / 1000\n      );\n      const alignedTimes = {\n        start: startNs - (startNs % 1e9),\n        end: endNs + (1e9 - (endNs % 1e9)),\n      };\n\n      range = {\n        start: alignedTimes.start,\n        end: alignedTimes.end,\n        step,\n      };\n    }\n\n    return {\n      ...DEFAULT_QUERY_PARAMS,\n      ...range,\n      query,\n      limit: Math.min((options as DataQueryRequest<LokiQuery>).maxDataPoints || Infinity, this.maxLines),\n    };\n  }\n\n  /**\n   * Attempts to send a query to /loki/api/v1/query_range\n   */\n  runRangeQuery = (\n    target: LokiQuery,\n    options: RangeQueryOptions,\n    responseListLength = 1\n  ): Observable<DataQueryResponse> => {\n    // target.maxLines value already preprocessed\n    // available cases:\n    // 1) empty input -> mapped to NaN, falls back to dataSource.maxLines limit\n    // 2) input with at least 1 character and that is either incorrect (value in the input field is not a number) or negative\n    //    - mapped to 0, falls back to the limit of 0 lines\n    // 3) default case - correct input, mapped to the value from the input field\n\n    let linesLimit = 0;\n    if (target.maxLines === undefined) {\n      // no target.maxLines, using options.maxDataPoints\n      linesLimit = Math.min((options as DataQueryRequest<LokiQuery>).maxDataPoints || Infinity, this.maxLines);\n    } else {\n      // using target.maxLines\n      if (isNaN(target.maxLines)) {\n        linesLimit = this.maxLines;\n      } else {\n        linesLimit = target.maxLines;\n      }\n    }\n\n    const queryOptions = { ...options, maxDataPoints: linesLimit };\n    if ((options as DataQueryRequest<LokiQuery>).liveStreaming) {\n      return this.runLiveQuery(target, queryOptions);\n    }\n    const query = this.createRangeQuery(target, queryOptions);\n    return this._request(RANGE_QUERY_ENDPOINT, query).pipe(\n      catchError((err: any) => this.throwUnless(err, err.status === 404, target)),\n      switchMap((response: { data: LokiResponse; status: number }) =>\n        processRangeQueryResponse(\n          response.data,\n          target,\n          query,\n          responseListLength,\n          linesLimit,\n          this.instanceSettings.jsonData,\n          (options as DataQueryRequest<LokiQuery>).scopedVars,\n          (options as DataQueryRequest<LokiQuery>).reverse\n        )\n      )\n    );\n  };\n\n  createLiveTarget(target: LokiQuery, options: { maxDataPoints?: number }): LokiLiveTarget {\n    const query = target.expr;\n    const baseUrl = this.instanceSettings.url;\n    const params = serializeParams({ query });\n\n    return {\n      query,\n      url: convertToWebSocketUrl(`${baseUrl}/loki/api/v1/tail?${params}`),\n      refId: target.refId,\n      size: Math.min(options.maxDataPoints || Infinity, this.maxLines),\n    };\n  }\n\n  /**\n   * Runs live queries which in this case means creating a websocket and listening on it for new logs.\n   * This returns a bit different dataFrame than runQueries as it returns single dataframe even if there are multiple\n   * Loki streams, sets only common labels on dataframe.labels and has additional dataframe.fields.labels for unique\n   * labels per row.\n   */\n  runLiveQuery = (target: LokiQuery, options: { maxDataPoints?: number }): Observable<DataQueryResponse> => {\n    const liveTarget = this.createLiveTarget(target, options);\n\n    return this.streams.getStream(liveTarget).pipe(\n      map(data => ({\n        data,\n        key: `loki-${liveTarget.refId}`,\n        state: LoadingState.Streaming,\n      }))\n    );\n  };\n\n  interpolateVariablesInQueries(queries: LokiQuery[], scopedVars: ScopedVars): LokiQuery[] {\n    let expandedQueries = queries;\n    if (queries && queries.length) {\n      expandedQueries = queries.map(query => ({\n        ...query,\n        datasource: this.name,\n        expr: this.templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr),\n      }));\n    }\n\n    return expandedQueries;\n  }\n\n  getQueryDisplayText(query: LokiQuery) {\n    return query.expr;\n  }\n\n  async importQueries(queries: LokiQuery[], originMeta: PluginMeta): Promise<LokiQuery[]> {\n    return this.languageProvider.importQueries(queries, originMeta.id);\n  }\n\n  async metadataRequest(url: string, params?: Record<string, string | number>) {\n    const res = await this._request(url, params, { hideFromInspector: true }).toPromise();\n    return res.data.data || res.data.values || [];\n  }\n\n  async metricFindQuery(query: string, optionalOptions?: any) {\n    if (!query) {\n      return Promise.resolve([]);\n    }\n    const interpolated = this.templateSrv.replace(query, {}, this.interpolateQueryExpr);\n    return await this.processMetricFindQuery(interpolated, optionalOptions?.range);\n  }\n\n  async processMetricFindQuery(query: string, range?: TimeRange) {\n    const labelNamesRegex = /^label_names\\(\\)\\s*$/;\n    const labelValuesRegex = /^label_values\\((?:(.+),\\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\\)\\s*$/;\n\n    const timeRange = range || getTimeSrv().timeRange();\n    const params = rangeToParams({ from: timeRange.from.valueOf(), to: timeRange.to.valueOf() });\n\n    const labelNames = query.match(labelNamesRegex);\n    if (labelNames) {\n      return await this.labelNamesQuery(params);\n    }\n\n    const labelValues = query.match(labelValuesRegex);\n    if (labelValues) {\n      return await this.labelValuesQuery(labelValues[2], params);\n    }\n\n    return Promise.resolve([]);\n  }\n\n  async labelNamesQuery(params?: Record<string, string | number>) {\n    const url = `${LOKI_ENDPOINT}/label`;\n    const result = await this.metadataRequest(url, params);\n    return result.map((value: string) => ({ text: value }));\n  }\n\n  async labelValuesQuery(label: string, params?: Record<string, string | number>) {\n    const url = `${LOKI_ENDPOINT}/label/${label}/values`;\n    const result = await this.metadataRequest(url, params);\n    return result.map((value: string) => ({ text: value }));\n  }\n\n  interpolateQueryExpr(value: any, variable: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return lokiRegularEscape(value);\n    }\n\n    if (typeof value === 'string') {\n      return lokiSpecialRegexEscape(value);\n    }\n\n    const escapedValues = lodashMap(value, lokiSpecialRegexEscape);\n    return escapedValues.join('|');\n  }\n\n  modifyQuery(query: LokiQuery, action: any): LokiQuery {\n    let expression = query.expr ?? '';\n    switch (action.type) {\n      case 'ADD_FILTER': {\n        expression = addLabelToQuery(expression, action.key, action.value, undefined, true);\n        break;\n      }\n      case 'ADD_FILTER_OUT': {\n        expression = addLabelToQuery(expression, action.key, action.value, '!=', true);\n        break;\n      }\n      default:\n        break;\n    }\n    return { ...query, expr: expression };\n  }\n\n  getHighlighterExpression(query: LokiQuery): string[] {\n    return getHighlighterExpressionsFromQuery(query.expr);\n  }\n\n  getTime(date: string | DateTime, roundUp: boolean) {\n    if (typeof date === 'string') {\n      date = dateMath.parse(date, roundUp)!;\n    }\n\n    return Math.ceil(date.valueOf() * 1e6);\n  }\n\n  getLogRowContext = (row: LogRowModel, options?: RowContextOptions): Promise<{ data: DataFrame[] }> => {\n    const target = this.prepareLogRowContextQueryTarget(\n      row,\n      (options && options.limit) || 10,\n      (options && options.direction) || 'BACKWARD'\n    );\n\n    const reverse = options && options.direction === 'FORWARD';\n    return this._request(RANGE_QUERY_ENDPOINT, target)\n      .pipe(\n        catchError((err: any) => {\n          if (err.status === 404) {\n            return of(err);\n          }\n\n          const error: DataQueryError = {\n            message: 'Error during context query. Please check JS console logs.',\n            status: err.status,\n            statusText: err.statusText,\n          };\n          throw error;\n        }),\n        switchMap((res: { data: LokiStreamResponse; status: number }) =>\n          of({\n            data: res.data ? res.data.data.result.map(stream => lokiStreamResultToDataFrame(stream, reverse)) : [],\n          })\n        )\n      )\n      .toPromise();\n  };\n\n  prepareLogRowContextQueryTarget = (row: LogRowModel, limit: number, direction: 'BACKWARD' | 'FORWARD') => {\n    const query = Object.keys(row.labels)\n      .map(label => `${label}=\"${row.labels[label].replace(/\\\\/g, '\\\\\\\\')}\"`) // escape backslashes in label as users can't escape them by themselves\n      .join(',');\n\n    const contextTimeBuffer = 2 * 60 * 60 * 1000; // 2h buffer\n    const commonTargetOptions = {\n      limit,\n      query: `{${query}}`,\n      expr: `{${query}}`,\n      direction,\n    };\n\n    const fieldCache = new FieldCache(row.dataFrame);\n    const nsField = fieldCache.getFieldByName('tsNs')!;\n    const nsTimestamp = nsField.values.get(row.rowIndex);\n\n    if (direction === 'BACKWARD') {\n      return {\n        ...commonTargetOptions,\n        // convert to ns, we loose some precision here but it is not that important at the far points of the context\n        start: row.timeEpochMs - contextTimeBuffer + '000000',\n        end: nsTimestamp,\n        direction,\n      };\n    } else {\n      return {\n        ...commonTargetOptions,\n        // start param in Loki API is inclusive so we'll have to filter out the row that this request is based from\n        // and any other that were logged in the same ns but before the row. Right now these rows will be lost\n        // because the are before but came it he response that should return only rows after.\n        start: nsTimestamp,\n        // convert to ns, we loose some precision here but it is not that important at the far points of the context\n        end: row.timeEpochMs + contextTimeBuffer + '000000',\n      };\n    }\n  };\n\n  testDatasource() {\n    // Consider only last 10 minutes otherwise request takes too long\n    const startMs = Date.now() - 10 * 60 * 1000;\n    const start = `${startMs}000000`; // API expects nanoseconds\n    return this._request(`${LOKI_ENDPOINT}/label`, { start })\n      .pipe(\n        map(res => {\n          const values: any[] = res?.data?.data || res?.data?.values || [];\n          const testResult =\n            values.length > 0\n              ? { status: 'success', message: 'Data source connected and labels found.' }\n              : {\n                  status: 'error',\n                  message:\n                    'Data source connected, but no labels received. Verify that Loki and Promtail is configured properly.',\n                };\n          return testResult;\n        }),\n        catchError((err: any) => {\n          let message = 'Loki: ';\n          if (err.statusText) {\n            message += err.statusText;\n          } else {\n            message += 'Cannot connect to Loki';\n          }\n\n          if (err.status) {\n            message += `. ${err.status}`;\n          }\n\n          if (err.data && err.data.message) {\n            message += `. ${err.data.message}`;\n          } else if (err.data) {\n            message += `. ${err.data}`;\n          }\n          return of({ status: 'error', message: message });\n        })\n      )\n      .toPromise();\n  }\n\n  async annotationQuery(options: AnnotationQueryRequest<LokiQuery>): Promise<AnnotationEvent[]> {\n    if (!options.annotation.expr) {\n      return [];\n    }\n\n    const interpolatedExpr = this.templateSrv.replace(options.annotation.expr, {}, this.interpolateQueryExpr);\n    const query = { refId: `annotation-${options.annotation.name}`, expr: interpolatedExpr };\n    const { data } = await this.runRangeQuery(query, options as any).toPromise();\n    const annotations: AnnotationEvent[] = [];\n\n    for (const frame of data) {\n      const tags: string[] = [];\n      for (const field of frame.fields) {\n        if (field.labels) {\n          tags.push.apply(tags, [...new Set(Object.values(field.labels).map((label: string) => label.trim()))]);\n        }\n      }\n      const view = new DataFrameView<{ ts: string; line: string }>(frame);\n\n      view.forEach(row => {\n        annotations.push({\n          time: new Date(row.ts).valueOf(),\n          text: row.line,\n          tags,\n        });\n      });\n    }\n\n    return annotations;\n  }\n\n  showContextToggle(row?: LogRowModel): boolean {\n    return (row && row.searchWords && row.searchWords.length > 0) === true;\n  }\n\n  throwUnless(err: FetchError, condition: boolean, target: LokiQuery) {\n    if (condition) {\n      return of(err);\n    }\n\n    const error = this.processError(err, target);\n    throw error;\n  }\n\n  processError(err: FetchError, target: LokiQuery) {\n    let error = cloneDeep(err);\n    if (err.data.message.includes('escape') && target.expr.includes('\\\\')) {\n      error.data.message = `Error: ${err.data.message}. Make sure that all special characters are escaped with \\\\. For more information on escaping of special characters visit LogQL documentation at https://github.com/grafana/loki/blob/master/docs/logql.md.`;\n    }\n    return error;\n  }\n\n  adjustInterval(interval: number, range: number) {\n    // Loki will drop queries that might return more than 11000 data points.\n    // Calibrate interval if it is too small.\n    if (interval !== 0 && range / interval > 11000) {\n      interval = Math.ceil(range / 11000);\n    }\n    return Math.max(interval, 1000);\n  }\n}\n\nexport function lokiRegularEscape(value: any) {\n  if (typeof value === 'string') {\n    return value.replace(/'/g, \"\\\\\\\\'\");\n  }\n  return value;\n}\n\nexport function lokiSpecialRegexEscape(value: any) {\n  if (typeof value === 'string') {\n    return lokiRegularEscape(value.replace(/\\\\/g, '\\\\\\\\\\\\\\\\').replace(/[$^*{}\\[\\]+?.()|]/g, '\\\\\\\\$&'));\n  }\n  return value;\n}\n\nexport default LokiDatasource;\n","// Libraries\nimport _ from 'lodash';\nimport LRU from 'lru-cache';\n\n// Services & Utils\nimport {\n  parseSelector,\n  labelRegexp,\n  selectorRegexp,\n  processLabels,\n} from 'app/plugins/datasource/prometheus/language_utils';\nimport syntax, { FUNCTIONS } from './syntax';\n\n// Types\nimport { LokiQuery } from './types';\nimport { dateTime, AbsoluteTimeRange, LanguageProvider, HistoryItem } from '@grafana/data';\nimport { PromQuery } from '../prometheus/types';\nimport { RATE_RANGES } from '../prometheus/promql';\n\nimport LokiDatasource from './datasource';\nimport { CompletionItem, TypeaheadInput, TypeaheadOutput, CompletionItemGroup } from '@grafana/ui';\nimport { Grammar } from 'prismjs';\n\nconst DEFAULT_KEYS = ['job', 'namespace'];\nconst EMPTY_SELECTOR = '{}';\nconst HISTORY_ITEM_COUNT = 10;\nconst HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h\nconst NS_IN_MS = 1000000;\nexport const LABEL_REFRESH_INTERVAL = 1000 * 30; // 30sec\n\nconst wrapLabel = (label: string) => ({ label });\nexport const rangeToParams = (range: AbsoluteTimeRange) => ({ start: range.from * NS_IN_MS, end: range.to * NS_IN_MS });\n\nexport type LokiHistoryItem = HistoryItem<LokiQuery>;\n\ntype TypeaheadContext = {\n  history?: LokiHistoryItem[];\n  absoluteRange?: AbsoluteTimeRange;\n};\n\nexport function addHistoryMetadata(item: CompletionItem, history: LokiHistoryItem[]): CompletionItem {\n  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;\n  const historyForItem = history.filter(h => h.ts > cutoffTs && h.query.expr === item.label);\n  let hint = `在最近24小时内查询 ${historyForItem.length} 次。`;\n  const recent = historyForItem[0];\n\n  if (recent) {\n    const lastQueried = dateTime(recent.ts).fromNow();\n    hint = `${hint} 最后查询 ${lastQueried}.`;\n  }\n\n  return {\n    ...item,\n    documentation: hint,\n  };\n}\n\nexport default class LokiLanguageProvider extends LanguageProvider {\n  labelKeys: string[];\n  logLabelOptions: any[];\n  logLabelFetchTs: number;\n  started: boolean;\n  initialRange: AbsoluteTimeRange;\n  datasource: LokiDatasource;\n  lookupsDisabled: boolean; // Dynamically set to true for big/slow instances\n\n  /**\n   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does\n   *  not account for different size of a response. If that is needed a `length` function can be added in the options.\n   *  10 as a max size is totally arbitrary right now.\n   */\n  private seriesCache = new LRU<string, Record<string, string[]>>(10);\n  private labelsCache = new LRU<string, string[]>(10);\n\n  constructor(datasource: LokiDatasource, initialValues?: any) {\n    super();\n\n    this.datasource = datasource;\n    this.labelKeys = [];\n    this.logLabelFetchTs = 0;\n\n    Object.assign(this, initialValues);\n  }\n\n  // Strip syntax chars\n  cleanText = (s: string) => s.replace(/[{}[\\]=\"(),!~+\\-*/^%]/g, '').trim();\n\n  getSyntax(): Grammar {\n    return syntax;\n  }\n\n  request = async (url: string, params?: any): Promise<any> => {\n    try {\n      return await this.datasource.metadataRequest(url, params);\n    } catch (error) {\n      console.error(error);\n    }\n\n    return undefined;\n  };\n\n  /**\n   * Initialise the language provider by fetching set of labels. Without this initialisation the provider would return\n   * just a set of hardcoded default labels on provideCompletionItems or a recent queries from history.\n   */\n  start = () => {\n    if (!this.startTask) {\n      this.startTask = this.fetchLogLabels(this.initialRange).then(() => {\n        this.started = true;\n        return [];\n      });\n    }\n\n    return this.startTask;\n  };\n\n  getLabelKeys(): string[] {\n    return this.labelKeys;\n  }\n\n  /**\n   * Return suggestions based on input that can be then plugged into a typeahead dropdown.\n   * Keep this DOM-free for testing\n   * @param input\n   * @param context Is optional in types but is required in case we are doing getLabelCompletionItems\n   * @param context.absoluteRange Required in case we are doing getLabelCompletionItems\n   * @param context.history Optional used only in getEmptyCompletionItems\n   */\n  async provideCompletionItems(input: TypeaheadInput, context?: TypeaheadContext): Promise<TypeaheadOutput> {\n    const { wrapperClasses, value, prefix, text } = input;\n    const emptyResult: TypeaheadOutput = { suggestions: [] };\n\n    if (!value) {\n      return emptyResult;\n    }\n\n    // Local text properties\n    const empty = value?.document.text.length === 0;\n    const selectedLines = value.document.getTextsAtRange(value.selection);\n    const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;\n\n    const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null;\n\n    // Syntax spans have 3 classes by default. More indicate a recognized token\n    const tokenRecognized = wrapperClasses.length > 3;\n\n    // Non-empty prefix, but not inside known token\n    const prefixUnrecognized = prefix && !tokenRecognized;\n\n    // Prevent suggestions in `function(|suffix)`\n    const noSuffix = !nextCharacter || nextCharacter === ')';\n\n    // Prefix is safe if it does not immediately follow a complete expression and has no text after it\n    const safePrefix = prefix && !text.match(/^['\"~=\\]})\\s]+$/) && noSuffix;\n\n    // About to type next operand if preceded by binary operator\n    const operatorsPattern = /[+\\-*/^%]/;\n    const isNextOperand = text.match(operatorsPattern);\n\n    // Determine candidates by CSS context\n    if (wrapperClasses.includes('context-range')) {\n      // Suggestions for metric[|]\n      return this.getRangeCompletionItems();\n    } else if (wrapperClasses.includes('context-labels')) {\n      // Suggestions for {|} and {foo=|}\n      return await this.getLabelCompletionItems(input, context);\n    } else if (empty) {\n      // Suggestions for empty query field\n      return this.getEmptyCompletionItems(context);\n    } else if (prefixUnrecognized && noSuffix && !isNextOperand) {\n      // Show term suggestions in a couple of scenarios\n      return this.getBeginningCompletionItems(context);\n    } else if (prefixUnrecognized && safePrefix) {\n      // Show term suggestions in a couple of scenarios\n      return this.getTermCompletionItems();\n    }\n\n    return emptyResult;\n  }\n\n  getBeginningCompletionItems = (context?: TypeaheadContext): TypeaheadOutput => {\n    return {\n      suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions],\n    };\n  };\n\n  getEmptyCompletionItems(context?: TypeaheadContext): TypeaheadOutput {\n    const history = context?.history;\n    const suggestions = [];\n\n    if (history && history.length) {\n      const historyItems = _.chain(history)\n        .map(h => h.query.expr)\n        .filter()\n        .uniq()\n        .take(HISTORY_ITEM_COUNT)\n        .map(wrapLabel)\n        .map((item: CompletionItem) => addHistoryMetadata(item, history))\n        .value();\n\n      suggestions.push({\n        prefixMatch: true,\n        skipSort: true,\n        label: '历史',\n        items: historyItems,\n      });\n    }\n\n    return { suggestions };\n  }\n\n  getTermCompletionItems = (): TypeaheadOutput => {\n    const suggestions = [];\n\n    suggestions.push({\n      prefixMatch: true,\n      label: '功能',\n      items: FUNCTIONS.map(suggestion => ({ ...suggestion, kind: 'function' })),\n    });\n\n    return { suggestions };\n  };\n\n  getRangeCompletionItems(): TypeaheadOutput {\n    return {\n      context: 'context-range',\n      suggestions: [\n        {\n          label: '范围向量',\n          items: [...RATE_RANGES],\n        },\n      ],\n    };\n  }\n\n  async getLabelCompletionItems(\n    { text, wrapperClasses, labelKey, value }: TypeaheadInput,\n    { absoluteRange }: any\n  ): Promise<TypeaheadOutput> {\n    let context = 'context-labels';\n    const suggestions: CompletionItemGroup[] = [];\n    if (!value) {\n      return { context, suggestions: [] };\n    }\n    const line = value.anchorBlock.getText();\n    const cursorOffset = value.selection.anchor.offset;\n    const isValueStart = text.match(/^(=|=~|!=|!~)/);\n\n    // Get normalized selector\n    let selector;\n    let parsedSelector;\n    try {\n      parsedSelector = parseSelector(line, cursorOffset);\n      selector = parsedSelector.selector;\n    } catch {\n      selector = EMPTY_SELECTOR;\n    }\n\n    if (!isValueStart && selector === EMPTY_SELECTOR) {\n      // start task gets all labels\n      await this.start();\n      const allLabels = this.getLabelKeys();\n      return { context, suggestions: [{ label: `标签`, items: allLabels.map(wrapLabel) }] };\n    }\n\n    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];\n\n    let labelValues;\n    // Query labels for selector\n    if (selector) {\n      if (selector === EMPTY_SELECTOR && labelKey) {\n        const labelValuesForKey = await this.getLabelValues(labelKey, absoluteRange);\n        labelValues = { [labelKey]: labelValuesForKey };\n      } else {\n        labelValues = await this.getSeriesLabels(selector, absoluteRange);\n      }\n    }\n\n    if (!labelValues) {\n      console.warn(`服务器没为选择器=${selector}返回任何值`);\n      return { context, suggestions };\n    }\n\n    if ((text && isValueStart) || wrapperClasses.includes('attr-value')) {\n      // Label values\n      if (labelKey && labelValues[labelKey]) {\n        context = 'context-label-values';\n        suggestions.push({\n          label: `\"${labelKey}\"的标签值`,\n          items: labelValues[labelKey].map(wrapLabel),\n        });\n      }\n    } else {\n      // Label keys\n      const labelKeys = labelValues ? Object.keys(labelValues) : DEFAULT_KEYS;\n\n      if (labelKeys) {\n        const possibleKeys = _.difference(labelKeys, existingKeys);\n        if (possibleKeys.length) {\n          const newItems = possibleKeys.map(key => ({ label: key }));\n          const newSuggestion: CompletionItemGroup = { label: `标签`, items: newItems };\n          suggestions.push(newSuggestion);\n        }\n      }\n    }\n\n    return { context, suggestions };\n  }\n\n  async importQueries(queries: LokiQuery[], datasourceType: string): Promise<LokiQuery[]> {\n    if (datasourceType === 'prometheus') {\n      return Promise.all(\n        queries.map(async query => {\n          const expr = await this.importPrometheusQuery(query.expr);\n          const { ...rest } = query as PromQuery;\n          return {\n            ...rest,\n            expr,\n          };\n        })\n      );\n    }\n    // Return a cleaned LokiQuery\n    return queries.map(query => ({\n      refId: query.refId,\n      expr: '',\n    }));\n  }\n\n  async importPrometheusQuery(query: string): Promise<string> {\n    if (!query) {\n      return '';\n    }\n\n    // Consider only first selector in query\n    const selectorMatch = query.match(selectorRegexp);\n    if (!selectorMatch) {\n      return '';\n    }\n\n    const selector = selectorMatch[0];\n    const labels: { [key: string]: { value: any; operator: any } } = {};\n    selector.replace(labelRegexp, (_, key, operator, value) => {\n      labels[key] = { value, operator };\n      return '';\n    });\n\n    // Keep only labels that exist on origin and target datasource\n    await this.start(); // fetches all existing label keys\n    const existingKeys = this.labelKeys;\n    let labelsToKeep: { [key: string]: { value: any; operator: any } } = {};\n    if (existingKeys && existingKeys.length) {\n      // Check for common labels\n      for (const key in labels) {\n        if (existingKeys && existingKeys.includes(key)) {\n          // Should we check for label value equality here?\n          labelsToKeep[key] = labels[key];\n        }\n      }\n    } else {\n      // Keep all labels by default\n      labelsToKeep = labels;\n    }\n\n    const labelKeys = Object.keys(labelsToKeep).sort();\n    const cleanSelector = labelKeys\n      .map(key => `${key}${labelsToKeep[key].operator}${labelsToKeep[key].value}`)\n      .join(',');\n\n    return ['{', cleanSelector, '}'].join('');\n  }\n\n  async getSeriesLabels(selector: string, absoluteRange: AbsoluteTimeRange) {\n    if (this.lookupsDisabled) {\n      return undefined;\n    }\n    try {\n      return await this.fetchSeriesLabels(selector, absoluteRange);\n    } catch (error) {\n      // TODO: better error handling\n      console.error(error);\n      return undefined;\n    }\n  }\n\n  /**\n   * Fetches all label keys\n   * @param absoluteRange Fetches\n   */\n  async fetchLogLabels(absoluteRange: AbsoluteTimeRange): Promise<any> {\n    const url = '/loki/api/v1/label';\n    try {\n      this.logLabelFetchTs = Date.now().valueOf();\n      const rangeParams = absoluteRange ? rangeToParams(absoluteRange) : {};\n      const res = await this.request(url, rangeParams);\n      this.labelKeys = res.slice().sort();\n      this.logLabelOptions = this.labelKeys.map((key: string) => ({ label: key, value: key, isLeaf: false }));\n    } catch (e) {\n      console.error(e);\n    }\n    return [];\n  }\n\n  async refreshLogLabels(absoluteRange: AbsoluteTimeRange, forceRefresh?: boolean) {\n    if ((this.labelKeys && Date.now().valueOf() - this.logLabelFetchTs > LABEL_REFRESH_INTERVAL) || forceRefresh) {\n      await this.fetchLogLabels(absoluteRange);\n    }\n  }\n\n  /**\n   * Fetch labels for a selector. This is cached by it's args but also by the global timeRange currently selected as\n   * they can change over requested time.\n   * @param name\n   */\n  fetchSeriesLabels = async (match: string, absoluteRange: AbsoluteTimeRange): Promise<Record<string, string[]>> => {\n    const rangeParams = absoluteRange ? rangeToParams(absoluteRange) : { start: 0, end: 0 };\n    const url = '/loki/api/v1/series';\n    const { start, end } = rangeParams;\n\n    const cacheKey = this.generateCacheKey(url, start, end, match);\n    const params = { match, start, end };\n    let value = this.seriesCache.get(cacheKey);\n    if (!value) {\n      // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.\n      this.seriesCache.set(cacheKey, {});\n      const data = await this.request(url, params);\n      const { values } = processLabels(data);\n      value = values;\n      this.seriesCache.set(cacheKey, value);\n    }\n    return value;\n  };\n\n  // Cache key is a bit different here. We round up to a minute the intervals.\n  // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every\n  // millisecond while still actually getting all the keys for the correct interval. This still can create problems\n  // when user does not the newest values for a minute if already cached.\n  generateCacheKey(url: string, start: number, end: number, param: string): string {\n    return [url, this.roundTime(start), this.roundTime(end), param].join();\n  }\n\n  // Round nanos epoch to nearest 5 minute interval\n  roundTime(nanos: number): number {\n    return nanos ? Math.floor(nanos / NS_IN_MS / 1000 / 60 / 5) : 0;\n  }\n\n  async getLabelValues(key: string, absoluteRange = this.initialRange): Promise<string[]> {\n    return await this.fetchLabelValues(key, absoluteRange);\n  }\n\n  async fetchLabelValues(key: string, absoluteRange: AbsoluteTimeRange): Promise<string[]> {\n    const url = `/loki/api/v1/label/${key}/values`;\n    let values: string[] = [];\n    const rangeParams = absoluteRange ? rangeToParams(absoluteRange) : { start: 0, end: 0 };\n    const { start, end } = rangeParams;\n\n    const cacheKey = this.generateCacheKey(url, start, end, key);\n    const params = { start, end };\n\n    let value = this.labelsCache.get(cacheKey);\n    if (!value) {\n      try {\n        // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.\n        this.labelsCache.set(cacheKey, []);\n        const res = await this.request(url, params);\n        values = res.slice().sort();\n        value = values;\n        this.labelsCache.set(cacheKey, value);\n\n        this.logLabelOptions = this.addLabelValuesToOptions(key, values);\n      } catch (e) {\n        console.error(e);\n      }\n    } else {\n      this.logLabelOptions = this.addLabelValuesToOptions(key, value);\n    }\n    return value ?? [];\n  }\n\n  private addLabelValuesToOptions = (labelKey: string, values: string[]) => {\n    return this.logLabelOptions.map(keyOption =>\n      keyOption.value === labelKey\n        ? {\n            ...keyOption,\n            children: values.map(value => ({ label: value, value })),\n          }\n        : keyOption\n    );\n  };\n}\n","import { DataFrame, FieldType, parseLabels, KeyValue, CircularDataFrame } from '@grafana/data';\nimport { Observable, throwError } from 'rxjs';\nimport { webSocket } from 'rxjs/webSocket';\nimport { LokiTailResponse } from './types';\nimport { finalize, map, catchError } from 'rxjs/operators';\nimport { appendResponseToBufferedData } from './result_transformer';\n\n/**\n * Maps directly to a query in the UI (refId is key)\n */\nexport interface LokiLiveTarget {\n  query: string;\n  url: string;\n  refId: string;\n  size: number;\n}\n\n/**\n * Cache of websocket streams that can be returned as observable. In case there already is a stream for particular\n * target it is returned and on subscription returns the latest dataFrame.\n */\nexport class LiveStreams {\n  private streams: KeyValue<Observable<DataFrame[]>> = {};\n\n  getStream(target: LokiLiveTarget): Observable<DataFrame[]> {\n    let stream = this.streams[target.url];\n\n    if (stream) {\n      return stream;\n    }\n\n    const data = new CircularDataFrame({ capacity: target.size });\n    data.addField({ name: 'ts', type: FieldType.time, config: { displayName: 'Time' } });\n    data.addField({ name: 'tsNs', type: FieldType.time, config: { displayName: 'Time ns' } });\n    data.addField({ name: 'line', type: FieldType.string }).labels = parseLabels(target.query);\n    data.addField({ name: 'labels', type: FieldType.other }); // The labels for each line\n    data.addField({ name: 'id', type: FieldType.string });\n    data.meta = { ...data.meta, preferredVisualisationType: 'logs' };\n\n    stream = webSocket(target.url).pipe(\n      map((response: LokiTailResponse) => {\n        appendResponseToBufferedData(response, data);\n        return [data];\n      }),\n      catchError(err => {\n        return throwError(`error: ${err.reason}`);\n      }),\n      finalize(() => {\n        delete this.streams[target.url];\n      })\n    );\n    this.streams[target.url] = stream;\n\n    return stream;\n  }\n}\n","import { DataSourcePlugin } from '@grafana/data';\nimport Datasource from './datasource';\n\nimport LokiCheatSheet from './components/LokiCheatSheet';\nimport LokiExploreQueryEditor from './components/LokiExploreQueryEditor';\nimport LokiQueryEditor from './components/LokiQueryEditor';\nimport { LokiAnnotationsQueryCtrl } from './LokiAnnotationsQueryCtrl';\nimport { ConfigEditor } from './configuration/ConfigEditor';\n\nexport const plugin = new DataSourcePlugin(Datasource)\n  .setQueryEditor(LokiQueryEditor)\n  .setConfigEditor(ConfigEditor)\n  .setExploreQueryField(LokiExploreQueryEditor)\n  .setExploreStartPage(LokiCheatSheet)\n  .setAnnotationQueryCtrl(LokiAnnotationsQueryCtrl);\n","import escapeRegExp from 'lodash/escapeRegExp';\n\nexport function formatQuery(selector: string | undefined): string {\n  return `${selector || ''}`.trim();\n}\n\n/**\n * Returns search terms from a LogQL query.\n * E.g., `{} |= foo |=bar != baz` returns `['foo', 'bar']`.\n */\nexport function getHighlighterExpressionsFromQuery(input: string): string[] {\n  let expression = input;\n  const results = [];\n\n  // Consume filter expression from left to right\n  while (expression) {\n    const filterStart = expression.search(/\\|=|\\|~|!=|!~/);\n    // Nothing more to search\n    if (filterStart === -1) {\n      break;\n    }\n    // Drop terms for negative filters\n    const filterOperator = expression.substr(filterStart, 2);\n    const skip = expression.substr(filterStart).search(/!=|!~/) === 0;\n    expression = expression.substr(filterStart + 2);\n    if (skip) {\n      continue;\n    }\n    // Check if there is more chained\n    const filterEnd = expression.search(/\\|=|\\|~|!=|!~/);\n    let filterTerm;\n    if (filterEnd === -1) {\n      filterTerm = expression.trim();\n    } else {\n      filterTerm = expression.substr(0, filterEnd).trim();\n      expression = expression.substr(filterEnd);\n    }\n\n    // Unwrap the filter term by removing quotes\n    const quotedTerm = filterTerm.match(/^\"((?:[^\\\\\"]|\\\\\")*)\"$/);\n\n    if (quotedTerm) {\n      const unwrappedFilterTerm = quotedTerm[1];\n      const regexOperator = filterOperator === '|~';\n      results.push(regexOperator ? unwrappedFilterTerm : escapeRegExp(unwrappedFilterTerm));\n    } else {\n      return [];\n    }\n  }\n\n  return results;\n}\n","import _ from 'lodash';\nimport md5 from 'md5';\nimport { of } from 'rxjs';\n\nimport {\n  FieldType,\n  TimeSeries,\n  Labels,\n  DataFrame,\n  ArrayVector,\n  MutableDataFrame,\n  findUniqueLabels,\n  DataFrameView,\n  DataLink,\n  Field,\n  QueryResultMetaStat,\n  QueryResultMeta,\n  TimeSeriesValue,\n  ScopedVars,\n} from '@grafana/data';\n\nimport templateSrv from 'app/features/templating/template_srv';\nimport TableModel from 'app/core/table_model';\nimport { formatQuery, getHighlighterExpressionsFromQuery } from './query_utils';\nimport {\n  LokiRangeQueryRequest,\n  LokiResponse,\n  LokiMatrixResult,\n  LokiVectorResult,\n  TransformerOptions,\n  LokiResultType,\n  LokiStreamResult,\n  LokiTailResponse,\n  LokiQuery,\n  LokiOptions,\n  DerivedFieldConfig,\n  LokiStreamResponse,\n  LokiStats,\n} from './types';\n\n/**\n * Transforms LokiStreamResult structure into a dataFrame. Used when doing standard queries and newer version of Loki.\n */\nexport function lokiStreamResultToDataFrame(stream: LokiStreamResult, reverse?: boolean, refId?: string): DataFrame {\n  const labels: Labels = stream.stream;\n  const labelsString = Object.entries(labels)\n    .map(([key, val]) => `${key}=\"${val}\"`)\n    .sort()\n    .join('');\n\n  const times = new ArrayVector<string>([]);\n  const timesNs = new ArrayVector<string>([]);\n  const lines = new ArrayVector<string>([]);\n  const uids = new ArrayVector<string>([]);\n\n  for (const [ts, line] of stream.values) {\n    // num ns epoch in string, we convert it to iso string here so it matches old format\n    times.add(new Date(parseInt(ts.substr(0, ts.length - 6), 10)).toISOString());\n    timesNs.add(ts);\n    lines.add(line);\n    uids.add(createUid(ts, labelsString, line));\n  }\n\n  return constructDataFrame(times, timesNs, lines, uids, labels, reverse, refId);\n}\n\n/**\n * Constructs dataFrame with supplied fields and other data. Also makes sure it is properly reversed if needed.\n */\nfunction constructDataFrame(\n  times: ArrayVector<string>,\n  timesNs: ArrayVector<string>,\n  lines: ArrayVector<string>,\n  uids: ArrayVector<string>,\n  labels: Labels,\n  reverse?: boolean,\n  refId?: string\n) {\n  const dataFrame = {\n    refId,\n    fields: [\n      { name: 'ts', type: FieldType.time, config: { displayName: 'Time' }, values: times }, // Time\n      { name: 'line', type: FieldType.string, config: {}, values: lines, labels }, // Line - needs to be the first field with string type\n      { name: 'id', type: FieldType.string, config: {}, values: uids },\n      { name: 'tsNs', type: FieldType.time, config: { displayName: 'Time ns' }, values: timesNs }, // Time\n    ],\n    length: times.length,\n  };\n\n  if (reverse) {\n    const mutableDataFrame = new MutableDataFrame(dataFrame);\n    mutableDataFrame.reverse();\n    return mutableDataFrame;\n  }\n\n  return dataFrame;\n}\n\n/**\n * Transform LokiResponse data and appends it to MutableDataFrame. Used for streaming where the dataFrame can be\n * a CircularDataFrame creating a fixed size rolling buffer.\n * TODO: Probably could be unified with the logStreamToDataFrame function.\n * @param response\n * @param data Needs to have ts, line, labels, id as fields\n */\nexport function appendResponseToBufferedData(response: LokiTailResponse, data: MutableDataFrame) {\n  // Should we do anything with: response.dropped_entries?\n\n  const streams: LokiStreamResult[] = response.streams;\n  if (!streams || !streams.length) {\n    return;\n  }\n\n  let baseLabels: Labels = {};\n  for (const f of data.fields) {\n    if (f.type === FieldType.string) {\n      if (f.labels) {\n        baseLabels = f.labels;\n      }\n      break;\n    }\n  }\n\n  for (const stream of streams) {\n    // Find unique labels\n    const unique = findUniqueLabels(stream.stream, baseLabels);\n    const allLabelsString = Object.entries(stream.stream)\n      .map(([key, val]) => `${key}=\"${val}\"`)\n      .sort()\n      .join('');\n\n    // Add each line\n    for (const [ts, line] of stream.values) {\n      data.values.ts.add(new Date(parseInt(ts.substr(0, ts.length - 6), 10)).toISOString());\n      data.values.tsNs.add(ts);\n      data.values.line.add(line);\n      data.values.labels.add(unique);\n      data.values.id.add(createUid(ts, allLabelsString, line));\n    }\n  }\n}\n\nfunction createUid(ts: string, labelsString: string, line: string): string {\n  return md5(`${ts}_${labelsString}_${line}`);\n}\n\nfunction lokiMatrixToTimeSeries(matrixResult: LokiMatrixResult, options: TransformerOptions): TimeSeries {\n  const name = createMetricLabel(matrixResult.metric, options);\n  return {\n    target: name,\n    title: name,\n    datapoints: lokiPointsToTimeseriesPoints(matrixResult.values, options),\n    tags: matrixResult.metric,\n    meta: options.meta,\n    refId: options.refId,\n  };\n}\n\nfunction lokiPointsToTimeseriesPoints(data: Array<[number, string]>, options: TransformerOptions): TimeSeriesValue[][] {\n  const stepMs = options.step * 1000;\n  const datapoints: TimeSeriesValue[][] = [];\n\n  let baseTimestampMs = options.start / 1e6;\n  for (const [time, value] of data) {\n    let datapointValue: TimeSeriesValue = parseFloat(value);\n\n    if (isNaN(datapointValue)) {\n      datapointValue = null;\n    }\n\n    const timestamp = time * 1000;\n    for (let t = baseTimestampMs; t < timestamp; t += stepMs) {\n      datapoints.push([0, t]);\n    }\n\n    baseTimestampMs = timestamp + stepMs;\n    datapoints.push([datapointValue, timestamp]);\n  }\n\n  const endTimestamp = options.end / 1e6;\n  for (let t = baseTimestampMs; t <= endTimestamp; t += stepMs) {\n    datapoints.push([0, t]);\n  }\n\n  return datapoints;\n}\n\nexport function lokiResultsToTableModel(\n  lokiResults: Array<LokiMatrixResult | LokiVectorResult>,\n  resultCount: number,\n  refId: string,\n  meta: QueryResultMeta,\n  valueWithRefId?: boolean\n): TableModel {\n  if (!lokiResults || lokiResults.length === 0) {\n    return new TableModel();\n  }\n\n  // Collect all labels across all metrics\n  const metricLabels: Set<string> = new Set<string>(\n    lokiResults.reduce((acc, cur) => acc.concat(Object.keys(cur.metric)), [] as string[])\n  );\n\n  // Sort metric labels, create columns for them and record their index\n  const sortedLabels = [...metricLabels.values()].sort();\n  const table = new TableModel();\n  table.refId = refId;\n  table.meta = meta;\n  table.columns = [\n    { text: 'Time', type: FieldType.time },\n    ...sortedLabels.map(label => ({ text: label, filterable: true })),\n    { text: resultCount > 1 || valueWithRefId ? `Value #${refId}` : 'Value', type: FieldType.number },\n  ];\n\n  // Populate rows, set value to empty string when label not present.\n  lokiResults.forEach(series => {\n    const newSeries: LokiMatrixResult = {\n      metric: series.metric,\n      values: (series as LokiVectorResult).value\n        ? [(series as LokiVectorResult).value]\n        : (series as LokiMatrixResult).values,\n    };\n\n    if (!newSeries.values) {\n      return;\n    }\n\n    if (!newSeries.metric) {\n      table.rows.concat(newSeries.values.map(([a, b]) => [a * 1000, parseFloat(b)]));\n    } else {\n      table.rows.push(\n        ...newSeries.values.map(([a, b]) => [\n          a * 1000,\n          ...sortedLabels.map(label => newSeries.metric[label] || ''),\n          parseFloat(b),\n        ])\n      );\n    }\n  });\n\n  return table;\n}\n\nexport function createMetricLabel(labelData: { [key: string]: string }, options?: TransformerOptions) {\n  let label =\n    options === undefined || _.isEmpty(options.legendFormat)\n      ? getOriginalMetricName(labelData)\n      : renderTemplate(templateSrv.replace(options.legendFormat ?? '', options.scopedVars), labelData);\n\n  if (!label && options) {\n    label = options.query;\n  }\n  return label;\n}\n\nfunction renderTemplate(aliasPattern: string, aliasData: { [key: string]: string }) {\n  const aliasRegex = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\n  return aliasPattern.replace(aliasRegex, (_, g1) => (aliasData[g1] ? aliasData[g1] : g1));\n}\n\nfunction getOriginalMetricName(labelData: { [key: string]: string }) {\n  const metricName = labelData.__name__ || '';\n  delete labelData.__name__;\n  const labelPart = Object.entries(labelData)\n    .map(label => `${label[0]}=\"${label[1]}\"`)\n    .join(',');\n  return `${metricName}{${labelPart}}`;\n}\n\nexport function decamelize(s: string): string {\n  return s.replace(/[A-Z]/g, m => ` ${m.toLowerCase()}`);\n}\n\n// Turn loki stats { metric: value } into meta stat { title: metric, value: value }\nfunction lokiStatsToMetaStat(stats: LokiStats | undefined): QueryResultMetaStat[] {\n  const result: QueryResultMetaStat[] = [];\n\n  if (!stats) {\n    return result;\n  }\n\n  for (const section in stats) {\n    const values = stats[section];\n    for (const label in values) {\n      const value = values[label];\n      let unit;\n      if (/time/i.test(label) && value) {\n        unit = 's';\n      } else if (/bytes.*persecond/i.test(label)) {\n        unit = 'Bps';\n      } else if (/bytes/i.test(label)) {\n        unit = 'decbytes';\n      }\n      const title = `${_.capitalize(section)}: ${decamelize(label)}`;\n      result.push({ displayName: title, value, unit });\n    }\n  }\n\n  return result;\n}\n\nexport function lokiStreamsToDataframes(\n  response: LokiStreamResponse,\n  target: { refId: string; expr?: string },\n  limit: number,\n  config: LokiOptions,\n  reverse = false\n): DataFrame[] {\n  const data = limit > 0 ? response.data.result : [];\n  const stats: QueryResultMetaStat[] = lokiStatsToMetaStat(response.data.stats);\n  // Use custom mechanism to identify which stat we want to promote to label\n  const custom = {\n    lokiQueryStatKey: 'Summary: total bytes processed',\n  };\n\n  const meta: QueryResultMeta = {\n    searchWords: getHighlighterExpressionsFromQuery(formatQuery(target.expr)),\n    limit,\n    stats,\n    custom,\n    preferredVisualisationType: 'logs',\n  };\n\n  const series: DataFrame[] = data.map(stream => {\n    const dataFrame = lokiStreamResultToDataFrame(stream, reverse);\n    enhanceDataFrame(dataFrame, config);\n\n    return {\n      ...dataFrame,\n      refId: target.refId,\n      meta,\n    };\n  });\n\n  if (stats.length && !data.length) {\n    return [\n      {\n        fields: [],\n        length: 0,\n        refId: target.refId,\n        meta,\n      },\n    ];\n  }\n\n  return series;\n}\n\n/**\n * Adds new fields and DataLinks to DataFrame based on DataSource instance config.\n */\nexport const enhanceDataFrame = (dataFrame: DataFrame, config: LokiOptions | null): void => {\n  if (!config) {\n    return;\n  }\n\n  const derivedFields = config.derivedFields ?? [];\n  if (!derivedFields.length) {\n    return;\n  }\n  const derivedFieldsGrouped = _.groupBy(derivedFields, 'name');\n\n  const newFields = Object.values(derivedFieldsGrouped).map(fieldFromDerivedFieldConfig);\n\n  const view = new DataFrameView(dataFrame);\n  view.forEach((row: { line: string }) => {\n    for (const field of newFields) {\n      const logMatch = row.line.match(derivedFieldsGrouped[field.name][0].matcherRegex);\n      field.values.add(logMatch && logMatch[1]);\n    }\n  });\n\n  dataFrame.fields = [...dataFrame.fields, ...newFields];\n};\n\n/**\n * Transform derivedField config into dataframe field with config that contains link.\n */\nfunction fieldFromDerivedFieldConfig(derivedFieldConfigs: DerivedFieldConfig[]): Field<any, ArrayVector> {\n  const dataLinks = derivedFieldConfigs.reduce((acc, derivedFieldConfig) => {\n    // Having field.datasourceUid means it is an internal link.\n    if (derivedFieldConfig.datasourceUid) {\n      acc.push({\n        // Will be filled out later\n        title: '',\n        url: '',\n        // This is hardcoded for Jaeger or Zipkin not way right now to specify datasource specific query object\n        internal: {\n          query: { query: derivedFieldConfig.url },\n          datasourceUid: derivedFieldConfig.datasourceUid,\n        },\n      });\n    } else if (derivedFieldConfig.url) {\n      acc.push({\n        // We do not know what title to give here so we count on presentation layer to create a title from metadata.\n        title: '',\n        // This is hardcoded for Jaeger or Zipkin not way right now to specify datasource specific query object\n        url: derivedFieldConfig.url,\n      });\n    }\n    return acc;\n  }, [] as DataLink[]);\n\n  return {\n    name: derivedFieldConfigs[0].name,\n    type: FieldType.string,\n    config: {\n      links: dataLinks,\n    },\n    // We are adding values later on\n    values: new ArrayVector<string>([]),\n  };\n}\n\nexport function rangeQueryResponseToTimeSeries(\n  response: LokiResponse,\n  query: LokiRangeQueryRequest,\n  target: LokiQuery,\n  responseListLength: number,\n  scopedVars: ScopedVars\n): TimeSeries[] {\n  /** Show results of Loki metric queries only in graph */\n  const meta: QueryResultMeta = {\n    preferredVisualisationType: 'graph',\n  };\n  const transformerOptions: TransformerOptions = {\n    format: target.format,\n    legendFormat: target.legendFormat ?? '',\n    start: query.start!,\n    end: query.end!,\n    step: query.step!,\n    query: query.query,\n    responseListLength,\n    refId: target.refId,\n    meta,\n    valueWithRefId: target.valueWithRefId,\n    scopedVars,\n  };\n\n  switch (response.data.resultType) {\n    case LokiResultType.Vector:\n      return response.data.result.map(vecResult =>\n        lokiMatrixToTimeSeries({ metric: vecResult.metric, values: [vecResult.value] }, transformerOptions)\n      );\n    case LokiResultType.Matrix:\n      return response.data.result.map(matrixResult => lokiMatrixToTimeSeries(matrixResult, transformerOptions));\n    default:\n      return [];\n  }\n}\n\nexport function processRangeQueryResponse(\n  response: LokiResponse,\n  target: LokiQuery,\n  query: LokiRangeQueryRequest,\n  responseListLength: number,\n  limit: number,\n  config: LokiOptions,\n  scopedVars: ScopedVars,\n  reverse = false\n) {\n  switch (response.data.resultType) {\n    case LokiResultType.Stream:\n      return of({\n        data: lokiStreamsToDataframes(response as LokiStreamResponse, target, limit, config, reverse),\n        key: `${target.refId}_log`,\n      });\n\n    case LokiResultType.Vector:\n    case LokiResultType.Matrix:\n      return of({\n        data: rangeQueryResponseToTimeSeries(\n          response,\n          query,\n          {\n            ...target,\n            format: 'time_series',\n          },\n          responseListLength,\n          scopedVars\n        ),\n        key: target.refId,\n      });\n    default:\n      throw new Error(`Unknown result type \"${(response.data as any).resultType}\".`);\n  }\n}\n","import { Grammar } from 'prismjs';\nimport { CompletionItem } from '@grafana/ui';\n\nconst AGGREGATION_OPERATORS: CompletionItem[] = [\n  {\n    label: 'sum',\n    insertText: 'sum',\n    documentation: 'Calculate sum over dimensions',\n  },\n  {\n    label: 'min',\n    insertText: 'min',\n    documentation: 'Select minimum over dimensions',\n  },\n  {\n    label: 'max',\n    insertText: 'max',\n    documentation: 'Select maximum over dimensions',\n  },\n  {\n    label: 'avg',\n    insertText: 'avg',\n    documentation: 'Calculate the average over dimensions',\n  },\n  {\n    label: 'stddev',\n    insertText: 'stddev',\n    documentation: 'Calculate population standard deviation over dimensions',\n  },\n  {\n    label: 'stdvar',\n    insertText: 'stdvar',\n    documentation: 'Calculate population standard variance over dimensions',\n  },\n  {\n    label: 'count',\n    insertText: 'count',\n    documentation: 'Count number of elements in the vector',\n  },\n  {\n    label: 'bottomk',\n    insertText: 'bottomk',\n    documentation: 'Smallest k elements by sample value',\n  },\n  {\n    label: 'topk',\n    insertText: 'topk',\n    documentation: 'Largest k elements by sample value',\n  },\n];\n\nexport const RANGE_VEC_FUNCTIONS = [\n  {\n    insertText: 'count_over_time',\n    label: 'count_over_time',\n    detail: 'count_over_time(range-vector)',\n    documentation: 'The count of all values in the specified interval.',\n  },\n  {\n    insertText: 'rate',\n    label: 'rate',\n    detail: 'rate(v range-vector)',\n    documentation:\n      \"Calculates the per-second average rate of increase of the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. Also, the calculation extrapolates to the ends of the time range, allowing for missed scrapes or imperfect alignment of scrape cycles with the range's time period.\",\n  },\n];\n\nexport const FUNCTIONS = [...AGGREGATION_OPERATORS, ...RANGE_VEC_FUNCTIONS];\n\nconst tokenizer: Grammar = {\n  comment: {\n    pattern: /#.*/,\n  },\n  'context-aggregation': {\n    pattern: /((without|by)\\s*)\\([^)]*\\)/, // by ()\n    lookbehind: true,\n    inside: {\n      'label-key': {\n        pattern: /[^(),\\s][^,)]*[^),\\s]*/,\n        alias: 'attr-name',\n      },\n      punctuation: /[()]/,\n    },\n  },\n  'context-labels': {\n    pattern: /\\{[^}]*(?=})/,\n    greedy: true,\n    inside: {\n      comment: {\n        pattern: /#.*/,\n      },\n      'label-key': {\n        pattern: /[a-z_]\\w*(?=\\s*(=|!=|=~|!~))/,\n        alias: 'attr-name',\n        greedy: true,\n      },\n      'label-value': {\n        pattern: /\"(?:\\\\.|[^\\\\\"])*\"/,\n        greedy: true,\n        alias: 'attr-value',\n      },\n      punctuation: /[{]/,\n    },\n  },\n  function: new RegExp(`\\\\b(?:${FUNCTIONS.map(f => f.label).join('|')})(?=\\\\s*\\\\()`, 'i'),\n  'context-range': [\n    {\n      pattern: /\\[[^\\]]*(?=\\])/, // [1m]\n      inside: {\n        'range-duration': {\n          pattern: /\\b\\d+[smhdwy]\\b/i,\n          alias: 'number',\n        },\n      },\n    },\n    {\n      pattern: /(offset\\s+)\\w+/, // offset 1m\n      lookbehind: true,\n      inside: {\n        'range-duration': {\n          pattern: /\\b\\d+[smhdwy]\\b/i,\n          alias: 'number',\n        },\n      },\n    },\n  ],\n  number: /\\b-?\\d+((\\.\\d*)?([eE][+-]?\\d+)?)?\\b/,\n  operator: new RegExp(`/&&?|\\\\|?\\\\||!=?|<(?:=>?|<|>)?|>[>=]?`, 'i'),\n  punctuation: /[{}()`,.]/,\n};\n\nexport default tokenizer;\n","import { DataQuery, DataSourceJsonData, QueryResultMeta, ScopedVars } from '@grafana/data';\n\nexport interface LokiInstantQueryRequest {\n  query: string;\n  limit?: number;\n  time?: string;\n  direction?: 'BACKWARD' | 'FORWARD';\n}\n\nexport interface LokiRangeQueryRequest {\n  query: string;\n  limit?: number;\n  start?: number;\n  end?: number;\n  step?: number;\n  direction?: 'BACKWARD' | 'FORWARD';\n}\n\nexport enum LokiResultType {\n  Stream = 'streams',\n  Vector = 'vector',\n  Matrix = 'matrix',\n}\n\nexport interface LokiQuery extends DataQuery {\n  expr: string;\n  query?: string;\n  format?: string;\n  reverse?: boolean;\n  legendFormat?: string;\n  valueWithRefId?: boolean;\n  maxLines?: number;\n}\n\nexport interface LokiOptions extends DataSourceJsonData {\n  maxLines?: string;\n  derivedFields?: DerivedFieldConfig[];\n}\n\nexport interface LokiStats {\n  [component: string]: {\n    [label: string]: number;\n  };\n}\n\nexport interface LokiVectorResult {\n  metric: { [label: string]: string };\n  value: [number, string];\n}\n\nexport interface LokiVectorResponse {\n  status: string;\n  data: {\n    resultType: LokiResultType.Vector;\n    result: LokiVectorResult[];\n    stats?: LokiStats;\n  };\n}\n\nexport interface LokiMatrixResult {\n  metric: Record<string, string>;\n  values: Array<[number, string]>;\n}\n\nexport interface LokiMatrixResponse {\n  status: string;\n  data: {\n    resultType: LokiResultType.Matrix;\n    result: LokiMatrixResult[];\n    stats?: LokiStats;\n  };\n}\n\nexport interface LokiStreamResult {\n  stream: Record<string, string>;\n  values: Array<[string, string]>;\n}\n\nexport interface LokiStreamResponse {\n  status: string;\n  data: {\n    resultType: LokiResultType.Stream;\n    result: LokiStreamResult[];\n    stats?: LokiStats;\n  };\n}\n\nexport interface LokiTailResponse {\n  streams: LokiStreamResult[];\n  dropped_entries?: Array<{\n    labels: Record<string, string>;\n    timestamp: string;\n  }> | null;\n}\n\nexport type LokiResult = LokiVectorResult | LokiMatrixResult | LokiStreamResult;\nexport type LokiResponse = LokiVectorResponse | LokiMatrixResponse | LokiStreamResponse;\n\nexport interface LokiLogsStreamEntry {\n  line: string;\n  ts: string;\n}\n\nexport interface LokiExpression {\n  regexp: string;\n  query: string;\n}\n\nexport type DerivedFieldConfig = {\n  matcherRegex: string;\n  name: string;\n  url?: string;\n  datasourceUid?: string;\n};\n\nexport interface TransformerOptions {\n  format?: string;\n  legendFormat?: string;\n  step: number;\n  start: number;\n  end: number;\n  query: string;\n  responseListLength: number;\n  refId: string;\n  scopedVars: ScopedVars;\n  meta?: QueryResultMeta;\n  valueWithRefId?: boolean;\n}\n"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxNA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AAEA;AAEA;AAeA;AAAA;AAAA;AAAA;AACA;AAQA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAFA;AAKA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAEA;AACA;AAZA;AAAA;AAAA;AAqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaA;AAAA;AACA;AACA;AACA;AAHA;AAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;AAmBA;AArEA;AACA;AADA;AAAA;AAAA;AAEA;AACA;AACA;AAHA;AAuEA;;;;;;;;;;;;AC3FA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;;;;;;;;AAOA;AAMA;AACA;AACA;AACA;AADA;AAGA;AAJA;AAOA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AC7DA;;;AAGA;AAAA;AAAA;AAIA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AATA;AAAA;AAAA;AAWA;AACA;AAZA;AACA;AADA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAOA;AACA;AACA;AAHA;AACA;AAMA;;;;;;;;;;;;;;;;;AAEA;AACA;AADA;AAgBA;;;;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAHA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AANA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAOA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAZA;AAAA;AAAA;AACA;AADA;AAcA;AACA;AAfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAZA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;AAoBA;AAAA;AAGA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAQA;;;AAEA;AAAA;AACA;AADA;AAGA;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAMA;AAAA;AACA;AAAA;AAIA;AAAA;AACA;AAAA;AAEA;AAAA;AAGA;AAAA;AACA;AAAA;AAIA;AAAA;AACA;AAAA;AAAA;AAMA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAJA;AASA;;;;AAjGA;AACA;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAYA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;ACpCA;AACA;AAOA;AACA;AAIA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AAVA;AAqBA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AAGA;AAGA;AAQA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AACA;AADA;AACA;AADA;AACA;AAAA;AACA;AAFA;AAcA;AACA;AACA;AAhBA;AAkBA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAtBA;AAuBA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAzBA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAFA;AAPA;AAWA;AACA;AAhBA;AAAA;AAAA;AAiCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AAAA;AACA;AAAA;AAEA;AACA;AAFA;AAOA;AACA;AACA;AACA;AACA;AACA;AANA;AAYA;AArEA;AACA;AADA;AAAA;AAwEA;;;;;;;;;;;;;;;;;;;;;;;;ACxFA;AACA;AACA;AAQA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAQA;AAEA;AACA;;;;;;AAFA;AAQA;AACA;AACA;AACA;AACA;AACA;AAbA;AAiBA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AAA;AAAA;AACA;AADA;AACA;AAIA;AACA;AAAA;AACA;AADA;AACA;AADA;AACA;AAAA;AADA;AAAA;AAAA;AACA;AADA;AAoDA;AACA;AAAA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAAA;AACA;AADA;AAIA;AAEA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAAA;AAEA;AACA;AAhFA;AAsHA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAaA;AACA;AAhKA;AAqLA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAAA;AAMA;AACA;AA/LA;AA8SA;AACA;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAEA;AAAA;AAAA;AADA;AADA;AAOA;AACA;AA3UA;AA6UA;AACA;AAAA;AADA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AALA;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AA9WA;AACA;AACA;AALA;AAMA;AACA;AAbA;AAAA;AAAA;AAeA;AACA;AACA;AACA;AAAA;AAEA;AAFA;AACA;AAIA;AACA;AAxBA;AAAA;AAAA;AA0BA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AAFA;AAAA;AAJA;AAAA;AAAA;AACA;AADA;AASA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAgBA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAnDA;AAAA;AAAA;AAwFA;AACA;AACA;AAAA;A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A;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AAGA;;;;;AACA;;;;;;AACA;AACA;;AADA;AACA;;;;;;AAEA;AACA;;AADA;AACA;;AAGA;;;;;AACA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;AACA;;;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAKA;AALA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;;AAUA;AAAA;AACA;AACA;AAFA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AAKA;;;;;;;AACA;;;;;AACA;AACA;;AAEA;AACA;AACA;AAAA;;;;;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;AAEA;;;;;AACA;;;;;AACA;AACA;;;;AAEA;AACA;;;;;;;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AAGA;;;;;;;;;;AAIA;;;;;;AACA;;AAEA;AACA;;AACA;AACA;;AADA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAEA;AACA;;AACA;AACA;;;;;;;;;;;;;;;;;;;;AAEA;;;;;AACA;;;;;;AACA;AACA;;;;;;;;;;;;;;;AAGA;;;;;;;;AAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A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AAnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAoBA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAFA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AADA;AAEA;AAAA;AAFA;AAMA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AAEA;AAEA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAEA;;;;AAGA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAEA;AACA;AAEA;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAFA;AALA;AAUA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AAPA;AASA;AACA;AACA;AAMA;AACA;AAAA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AACA;AAaA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AADA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AARA;AAUA;AAEA;AASA;AACA;AAAA;AACA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AAKA;AALA;AAUA;AAXA;AACA;AAYA;AACA;AAvBA;AAyBA;;;;;;;;;;;;ACneA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAOA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AASA;AAEA;AACA;AACA;AADA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AALA;AAHA;AAWA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAHA;AAKA;AAdA;AAHA;AAoBA;AAAA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAFA;AADA;AAFA;AAUA;AAAA;AACA;AACA;AACA;AACA;AACA;AAFA;AADA;AAHA;AAWA;AACA;AACA;AA3DA;AA8DA;;;;;;;;;;;;ACjHA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;;;;A","sourceRoot":""}